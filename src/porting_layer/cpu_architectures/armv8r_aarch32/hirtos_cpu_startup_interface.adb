--
--  Copyright (c) 2022, German Rivera
--  All rights reserved.
--
--  SPDX-License-Identifier: BSD-3-Clause
--

with HiRTOS_Low_Level_Debug_Interface;
with HiRTOS_Cpu_Multi_Core_Interface;
with HiRTOS_Cpu_Arch_Interface.System_Registers;
with Memory_Utils;
with System.Machine_Code;
with Interfaces;

package body HiRTOS_Cpu_Startup_Interface is
   use HiRTOS_Cpu_Multi_Core_Interface;
   use HiRTOS_Cpu_Arch_Interface.System_Registers;
   use ASCII;

   ----------------
   -- Enable_FPU --
   ----------------

   procedure Enable_FPU is
      CPACR_Value : CPACR_Type;
      FPEXC_EN_Bit_Mask : constant Interfaces.Unsigned_32 := Interfaces.Shift_Left (1, 30);
   begin
      --
      --  Enable full access to FPU
      --
      CPACR_Value := Get_CPACR;
      CPACR_Value.cp10 := Advanced_SIMD_And_Floating_Point_Enabled_For_EL0_EL1;
      CPACR_Value.cp11 := Advanced_SIMD_And_Floating_Point_Enabled_For_EL0_EL1;
      Set_CPACR (CPACR_Value);

      System.Machine_Code.Asm (
         --
         --  Enable VFP instructions:
         --
         "isb" & LF &
         "vmrs r0, fpexc" & LF &
         "orr  r0, r0, %0" & LF &
         "vmsr fpexc, r0" & LF &

         --
         --  Initializes floating-point registers:
         --
         "mov  r0, #0" & LF &
         "vmov d0,  r0, r0" & LF &
         "vmov d1,  r0, r0" & LF &
         "vmov d2,  r0, r0" & LF &
         "vmov d3,  r0, r0" & LF &
         "vmov d4,  r0, r0" & LF &
         "vmov d5,  r0, r0" & LF &
         "vmov d6,  r0, r0" & LF &
         "vmov d7,  r0, r0" & LF &
         "vmov d8,  r0, r0" & LF &
         "vmov d9,  r0, r0" & LF &
         "vmov d10, r0, r0" & LF &
         "vmov d11, r0, r0" & LF &
         "vmov d12, r0, r0" & LF &
         "vmov d13, r0, r0" & LF &
         "vmov d14, r0, r0" & LF &
         "vmov d15, r0, r0" & LF &
         "vmsr fpscr, r0",
         Inputs => Interfaces.Unsigned_32'Asm_Input ("g", FPEXC_EN_Bit_Mask), --  %0
         Clobber => "r0",
         Volatile => True);
   end Enable_FPU;

   -----------------------
   -- Ada_Reset_Handler --
   -----------------------

   procedure Ada_Reset_Handler is
      procedure Gnat_Generated_Main with Import,
                                      Convention => C,
                                      External_Name => "main";
   begin
      Enable_FPU;

      --
      --  In case C code is invoked from Ada, C global variables
      --  need to be initialized in RAM:
      --
      Memory_Utils.Copy_Data_Section;
      Memory_Utils.Clear_BSS_Section;

      HiRTOS_Low_Level_Debug_Interface.Initialize_Led;
      HiRTOS_Low_Level_Debug_Interface.Initialize_Uart;

      --
      --  Call main() generated by gnat binder, which will do the elaboration
      --  of Ada library-level packages and then invoke the main Ada subprogram
      --
      --  NOTE: Before calling 'Gnat_Generated_Main' only
      --  "No_Elaboration_Code_All" packages can be invoked.
      --
      Gnat_Generated_Main;

      --
      --  We should not return here
      --
      loop
         HiRTOS_Cpu_Arch_Interface.Wait_For_Interrupt;
      end loop;
   end Ada_Reset_Handler;

   ----------------------------------
   -- Unexpected_Interrupt_Handler --
   ----------------------------------

   procedure Unexpected_Interrupt_Handler is
   begin
      loop
         HiRTOS_Cpu_Arch_Interface.Wait_For_Interrupt;
      end loop;
   end Unexpected_Interrupt_Handler;

   -------------------------
   -- Last_Chance_Handler --
   -------------------------

   Last_Chance_Handler_Running :
      array (Valid_Cpu_Core_Id_Type) of Boolean := [ others => False ];

   procedure Last_Chance_Handler (Msg : System.Address; Line : Integer) is
      Msg_Text : String (1 .. 128) with Address => Msg;
      Msg_Length : Natural := 0;
      Cpu_Id : constant Valid_Cpu_Core_Id_Type := Get_Cpu_Id;
   begin
      HiRTOS_Low_Level_Debug_Interface.Set_Led (True);
      --
      --  Calculate length of the null-terminated 'Msg' string:
      --
      for Msg_Char of Msg_Text loop
         Msg_Length := Msg_Length + 1;
         exit when Msg_Char = ASCII.NUL;
      end loop;

      if Last_Chance_Handler_Running (Cpu_Id) then
         HiRTOS_Low_Level_Debug_Interface.Print_String (
            "*** Recursive call to Last_Chance_Handler: " &
            Msg_Text (1 .. Msg_Length) & "' at line ");
         HiRTOS_Low_Level_Debug_Interface.Print_Number_Decimal (Interfaces.Unsigned_32 (Line),
                                                                End_Line => True);
         loop
            System.Machine_Code.Asm ("wfi", Volatile => True);
         end loop;
      end if;

      Last_Chance_Handler_Running (Cpu_Id) := True;

      --
      --  Print exception message to UART:
      --
      if Line /= 0 then
         HiRTOS_Low_Level_Debug_Interface.Print_String (
            ASCII.LF & "*** Exception: '" & Msg_Text (1 .. Msg_Length) &
            "' at line ");
         HiRTOS_Low_Level_Debug_Interface.Print_Number_Decimal (Interfaces.Unsigned_32 (Line),
                                                                End_Line => True);
      else
         HiRTOS_Low_Level_Debug_Interface.Print_String (
            ASCII.LF &
            "*** Exception: '" & Msg_Text (1 .. Msg_Length) & "'" & ASCII.LF);
      end if;

      loop
         HiRTOS_Cpu_Arch_Interface.Wait_For_Interrupt;
      end loop;

   end Last_Chance_Handler;

end HiRTOS_Cpu_Startup_Interface;
