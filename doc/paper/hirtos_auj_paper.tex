\documentclass{AUJarticle}
\usepackage[cmex10]{amsmath}
\usepackage[utf8x]{inputenc}
\usepackage[nocompress]{cite}
\usepackage{graphicx, multirow, booktabs, color, listings}
\usepackage{balance}
\usepackage[pdftex, pdfborder={0 0 0}]{hyperref}
%\usepackage[mathrm,colour,cntbysection]{czt}
\usepackage{zed-csp}
\usepackage{tikz-uml}

\graphicspath{{figures/}}

\pagestyle{empty}

\pdfinfo{ /Title (HiRTOS: A Multi-Core RTOS written in SPARK Ada)
  /Author (J. Germ\'an Rivera)
  /Keywords (Ada) }

\newcommand{\todo}{\textcolor{red}}

\hyphenation{}

\setcounter{page}{1}

\lstset{language=Ada,
        basicstyle=\small}

\begin{document}

\title{HiRTOS: A Multi-Core RTOS written in SPARK Ada}

\addauthor{J. Germ\'an Rivera}
{Austin, TX, USA}
{jgrivera67@gmail.com}

%\issuev{35}
%\issuen{1}
%\issued{March 2014}

\shortauthor{J. Germ\'an Rivera}
\shorttitle{HiRTOS: A Multi-Core RTOS written in SPARK Ada}

\thispagestyle{plain}

\maketitle

\begin{abstract}

This industrial presentation will describe the design of \emph{HiRTOS} (High-Integrity RTOS),
a simple real-time operating system kernel and separation kernel written in SPARK Ada.
HiRTOS targets safety-critical and security-sensitive embedded software applications
that run in multi-core microcontrollers.
HiRTOS was designed using the Z notation,
as a methodical way to capture correctness assumptions that can be expressed
as programming contracts in SPARK Ada. Z is a software modeling notation based
on discrete mathematics structures (such as sets, relations and functions)
and predicate logic.

Keywords: RTOS, multi-core, high-integrity, formal methods, Z, Ada, SPARK.

\end{abstract}

\section{Introduction}

Although there are several popular RTOSes for embedded applications that run on small
microcontrollers, most of them are not designed with high-integrity applications
in mind, and as such are written in C, a notoriously unsafe language. So, it would be desirable
to have an RTOS specifically designed for high-integrity applications, and written in a safer
language, like Ada or its subset SPARK Ada, even if application code is written in C/C++.
Modern versions of Ada and SPARK Ada have programming-by-contract constructs built-in
in the language, which allows the programmer to express correctness assumptions (contracts) as
part of the code. One challenge when doing programming-by-contract is to be aware of all the
correctness assumptions that can be checked in programming contracts. Describing software design
in a formal notation, such as the \href{http://en.wikipedia.org/wiki/Z_notation}{Z notation} \cite{Zrm, WayofZ},
can help identify/elicit correctness assumptions in a more methodical way than just thinking
of them as we write code.

Z is a software modeling notation based on discrete mathematics structures (such as sets,
relations and functions) and predicate logic. With Z, data structures can be specified in
terms of mathematical structures and their state invariants can be specified using mathematical
predicates. Specifying (designing) data structures at a higher-level of abstraction using
discrete-math structures can lead to simpler and more elegant code. The pre-conditions and
post-conditions of the operations that manipulate the data structures can also be specified
using predicates. Using Z for this purpose encourages a rigorous and methodical thought process
to elicit correctness properties, in a systematic way.
The \emph{HiRTOS} Z model described here was checked with the \verb'fuzz' tool~\cite{Fuzz}, a
Z type-checker, that catches Z type mismatches in predicates.

The code of \emph{HiRTOS} is written in SPARK Ada \cite{SparkAda}, a high integrity
subset of the Ada programming language. HiRTOS data types were modeled in Z at a level of
abstraction that can be mapped directly to corresponding data types in SPARK Ada.

The rest of this paper is organized as follows. Section 2 describes the code architecture of
HiRTOS and the major design decisions. Section 3 presents the Z specification of the main data
structures in HiRTOS. Section 4 presents the Z specification of the main operations of HiRTOS.

\section{HiRTOS Overview}

\subsection{Major Design Decisions}

\begin{itemize}
\item For API simplicity, inspired by the thread synchronization primitives of the C11 standard
library \cite{libcThreads}, mutexes and condition variables are the only synchronization
primitives in \emph{HiRTOS}.
Other synchronization primitives such as semaphores, event flags and message queues can be
implemented on top of mutexes and condition variables.

\item Unlike C11 mutexes, \emph{HiRTOS} mutexes can change the priority of the thread owning the
mutex. \emph{HiRTOS} mutexes support both priority inheritance and priority ceiling \cite{prioCeiling}.

\item Unlike C11 condition variables, \emph{HiRTOS} condition variables
can also be waited on while having interrupts disabled, not just while holding a mutex.

\item \emph{HiRTOS} atomic levels can be used to disable the thread scheduler or to disable interrupts
at and below a given priority or to disable all interrupts.

\item In a multi-core platform, there is one \emph{HiRTOS} instance per CPU Core. Each \emph{HiRTOS} instance is
independent of each other. No resources are shared between \emph{HiRTOS} instances. No communication between
CPU cores is supported by \emph{HiRTOS}, so that the \emph{HiRTOS} API can stay the same for both single-core
and multi-core platforms. Inter-core communication would need to be provided outside of \emph{HiRTOS},
using doorbell interrupts and mailboxes or shared memory, for example.

\item
Threads are bound to the CPU core in which they were created, for the lifetime of the thread. That is,
no thread migration between CPU cores is supported.

\item
All RTOS objects such as threads, mutexes and condition variables are allocated internally
by \emph{HiRTOS} from statically allocated internal object pools.
These object pools are just RTOS-private global arrays of the corresponding RTOS object types,
sized at compile time via configuration parameters, whose values are application-specific.
RTOS object handles provided to application code are just indices into these internal object arrays.
No actual RTOS object pointers exposed to application code.
No dynamic allocation/deallocation of RTOS objects is supported and no static allocation of RTOS
objects in memory owned by application code is supported either.

\item
All application threads run in unprivileged mode. For each thread, the only writable memory,
by default, is its own stack and global variables. Stacks of other threads are not accessible.
MMIO space is only accessible to privileged code, by default. Application driver code, other
than ISRs, must request access (read-only or read-write permission) to \emph{HiRTOS} via a
system call.

\item Interrupt service routines (ISRs) are seen as hardware-scheduled threads that have higher
priority than all software-scheduled threads. They can only be preempted by higher-priority ISRs.
They cannot block waiting on mutexes or condition variables.
\end{itemize}

\subsection{Separation Kernel Major Design Decisions}

Besides being a fully functional RTOS, HiRTOS can be used as a separation kernel \cite{SepK}.

\begin{itemize}

\item In a multi-core platform, there is one separation kernel instance per CPU Core. Each instance is
independent of each other. No resources are shared between separation kernel instances. No communication between
CPU cores is supported, so that the separation kernel API can stay the same for both single-core
and multi-core platforms. Inter-core communication would need to be provided outside of HiRTOS,
using doorbell interrupts and mailboxes or shared memory, for example.

\item Each separation-kernel instance consists of one or more partitions. A partition is a spatial and temporal
separation/isolation unit on which a bare-metal or RTOS-based firmware binary runs. Each partition
consists of one more disjoint address ranges covering portions of RAM and MMIO space that only that
partition can access. Also, each partition has its own interrupt vector table, its own set of physical
interrupts and its own global machine state. So, the firmware hosted in each partition has the illusion
that it owns an entire physical machine, with is own set of of physical peripherals, dedicated memory
and CPU core. The CPU core is time-sliced among the partitions running on the same separation kernel instance.

\item
Partitions are bound to the CPU core in which they were created. That is, no partition migration between
CPU cores is supported.

\item
Partitions are created at boot time before starting the partition scheduler on the corresponding CPU core.
Partitions cannot be destroyed or terminated.

\item
The separation kernel code itself runs in hypervisor privilege mode. All partitions run at a privilege lower
than hypervisor mode. Partitions can communicate with the separation kernel via hypervisor calls and via
traps to hypervisor mode triggered from special machine instructions such as $WFI$. The separation kernel
can communicate with partitions, by forwarding interrupts targeted to the corresponding partition.

\end{itemize}


\subsection{HiRTOS Code Architecture}

To have wider adoption of an RTOS written in bare-metal Ada, providing a C/C++ programming interface
is a must. Indeed, multiple interfaces or ``skins'' can be provided to mimic widely popular
RTOSes such as FreeRTOS \cite{freeRTOS} and RTOS interfaces such as the CMSIS RTOS2 API \cite{cmsisRTOS}.
As shown on figure \ref{HiRTOSAchitecture1}, HiRTOS has a C/C++ interface layer that provides
a FreeRTOS skin and and a CMSIS RTOS2 skin. Both skins are implemented on top of a native C skin.
The native C skin is just a thin C wrapper that consists of a C header file containing the C
functions prototypes of the corresponding Ada subprograms of the SPARK Ada native interface of HiRTOS.

In addition to the C/C++ interface, HiRTOS should also provide an Ada runtime library (RTS) skin,
as shown on figure \ref{HiRTOSAchitecture2}, so that baremetal Ada applications that use Ada tasking
features can run on top of HiRTOS. This can be especially useful, given the limited number of
microcontroller platforms for which there is a bare-metal Ada runtime library available with the
GNAT Ada compiler. an all platforms where is avaiable now or in the future.

HiRTOS has been architected to be easily portable to any multi-core microcontroller or bare metal
platform for which a GNAT Ada cross compiler is available. All platform-dependent code is isolated in the
HiRTOS porting layer, which provides platform-independent interfaces to the rest of the HiRTOS code.
To avoid any depdendency on a platform-specific bare-metal Ada runtime library, provided by the
compiler, HiRTOS sits on top of a platform-independent portable minimal Ada runtime library.

\begin{figure}
   \begin{center}
      \scalebox{0.58}{
         \begin{tikzpicture}
            \umlemptypackage[x=0, y=0]{Bare Metal C/C++ Applications}

            \begin{umlpackage}[x=0, y=-4]{C Interface Skins Library}
               \umlemptypackage[x=-3]{CMSIS RTOS2 Skin}
               \umlemptypackage[x=3]{FreeRTOS Skin}
               \umlemptypackage[x=6, y=-3]{C Interface Skin}
            \end{umlpackage}

            \begin{umlpackage}[x=0, y=-2]{HiRTOS Library Crate}
               \umlemptypackage[x=0, y=-10]{HiRTOS}
               \umlemptypackage[x=-4, y=-12]{HiRTOS Porting Layer}
            \end{umlpackage}

            \umlemptypackage[x=2, y=-18]{Portable Minimal Ada RTS Library Crate}

            \umlimport[geometry=|-]{CMSIS RTOS2 Skin}{C Interface Skin}
            \umlimport[geometry=|-]{FreeRTOS Skin}{C Interface Skin}
            \umlimport[geometry=|-]{C Interface Skin}{HiRTOS}
            \umlimport[geometry=|-]{HiRTOS}{HiRTOS Porting Layer}
            \umlimport[]{HiRTOS}{Portable Minimal Ada RTS Library Crate}
            \umlimport[geometry=|-]{HiRTOS Porting Layer}{Portable Minimal Ada RTS Library Crate}
            \umlimport[]{Bare Metal C/C++ Applications}{CMSIS RTOS2 Skin}
            \umlimport[]{Bare Metal C/C++ Applications}{FreeRTOS Skin}
            \umlimport[geometry=-|]{Bare Metal C/C++ Applications}{C Interface Skin}
         \end{tikzpicture}
      }
   \end{center}
   \caption{HiRTOS Code Architecture for C/C++ Applications}
   \label{HiRTOSAchitecture1}
\end{figure}

\begin{figure}
   \begin{center}
      \scalebox{0.58}{
         \begin{tikzpicture}
            \umlemptypackage[x=0, y=0]{Bare Metal Ada Applications}

            \umlemptypackage[x=0, y=-4]{Ada RTS Tasking Skin Library Crate}

            \begin{umlpackage}[x=0, y=-8]{HiRTOS Library Crate}
               \umlemptypackage[x=0, y=0]{HiRTOS}
               \umlemptypackage[x=-4, y=-1]{HiRTOS Config Parameters}
               \umlemptypackage[x=-4, y=-4]{HiRTOS Porting Layer}
            \end{umlpackage}

            \umlemptypackage[x=4, y=-16]{Portable Minimal Ada RTS Library Crate}

            \umlimport[]{Ada RTS Tasking Skin Library Crate}{HiRTOS}
            \umlimport[geometry=|-]{HiRTOS}{HiRTOS Porting Layer}
            \umlimport[]{HiRTOS}{Portable Minimal Ada RTS Library Crate}
            \umlimport[geometry=|-]{HiRTOS Porting Layer}{Portable Minimal Ada RTS Library Crate}
            \umlimport[]{Bare Metal Ada Applications}{Ada RTS Tasking Skin Library Crate}
            \umlimport[geometry=-|]{Bare Metal Ada Applications}{Portable Minimal Ada RTS Library Crate}
            \umlimport[geometry=|-]{HiRTOS}{HiRTOS Config Parameters}
         \end{tikzpicture}
      }
   \end{center}
   \caption{HiRTOS Code Architecture for Ada Applications}
   \label{HiRTOSAchitecture2}
\end{figure}

Figure \ref{HiRTOSAchitecture3} shows the major code components of HiRTOS. The HiRTOS code base is
structured in three conceptual layers. The \emph{HiRTOS API} layer, the \emph{HiRTOS internals layer}
and the \emph{HiRTOS porting layer}.

The \emph{HiRTOS API} layer contains the HiRTOS public interface components.
The \verb'HiRTOS_Interrupt_Handling' Ada package contains the services to be invoked from top-level
interrupt handlers to notify HiRTOS of entering an exiting interrupt context.
\verb'HiRTOS_Memory_Protection' contains the services to protect ranges of memory and MMIO space.
\verb'HiRTOS_Thread' contains the services to create and manage threads.

The \emph{HiRTOS internals layer} contains HiRTOS-private components that are
hardware-independent.

The \emph{HiRTOS porting layer} contains hardware-dependent components that
provide hardware-independent interfaces to upper HiRTOS layers.

\begin{figure}
   \begin{center}
      \scalebox{0.58}{
         \begin{tikzpicture}
            \begin{umlpackage}{HiRTOS}
               \begin{umlpackage}{HiRTOS API}
                  \umlbasiccomponent{HiRTOS}
                  \umlbasiccomponent[name=HiRTOSinterruptHandling, x=-3, y=-2.5]{HiRTOS.Interrupt\_Handling}
                  \umlbasiccomponent[name=HiRTOSmemoryProtection, x=2, y=-2.5]{HiRTOS.Memory\_Protection}
                  \umlbasiccomponent[name=HiRTOSthread, x=-3, y=-5]{HiRTOS.Thread}
                  \umlbasiccomponent[name=HiRTOStimer, x=2, y=-5]{HiRTOS.Timer}
                  \umlbasiccomponent[name=HiRTOScondvar, x=-3, y=-7.5]{HiRTOS.Condvar}
                  \umlbasiccomponent[name=HiRTOSmutex, x=2, y=-7.5]{HiRTOS.Mutex}
               \end{umlpackage}
               \begin{umlpackage}{HiRTOS internals}
                  \umlbasiccomponent[name=RTOSprivate, x=0, y=-11]{RTOS\_Private}
                  \umlbasiccomponent[name=HiRTOSinterruptHandlingPrivate, x=-3, y=-13.5]{HiRTOS.Interrupt\_Handling\_Private}
                  \umlbasiccomponent[name=HiRTOSmemoryProtectionPrivate, x=3, y=-13.5]{HiRTOS.Memory\_Protection\_Private}
                  \umlbasiccomponent[name=HiRTOSthreadPrivate, x=-3, y=-16]{HiRTOS.Thread\_Private}
                  \umlbasiccomponent[name=HiRTOStimerPrivate, x=2, y=-16]{HiRTOS.TimerPrivate}
                  \umlbasiccomponent[name=HiRTOScondvarPrivate, x=-3, y=-18.5]{HiRTOS.CondvarPrivate}
                  \umlbasiccomponent[name=HiRTOSmutexPrivate, x=2, y=-18.5]{HiRTOS.MutexPrivate}
               \end{umlpackage}
               \umlbasiccomponent[name=GenericLinkedList, x=2, y=-21.5]{Generic\_Linked\_List}
               \umlbasiccomponent[name=GenericExecutionStack, x=-3, y=-21.5]{Generic\_Execution\_Stack}
            \end{umlpackage}

            \begin{umlpackage}{HiRTOS Porting Layer}
               \begin{umlpackage}{Cpu Architecture Specific}
                  \umlbasiccomponent[name=HiRTOScpuArchParameters, x=-3, y=-26]{HiRTOS\_Cpu\_Arch\_Parameters}
                  \umlbasiccomponent[name=HiRTOScpuArchInterface, x=-3, y=-28.5]{HiRTOS\_Cpu\_Interface}
                  \umlbasiccomponent[name=HiRTOScpuStartupInterface, x=-3, y=-31]{HiRTOS\_Cpu\_Startup\_Interface}
                  \umlbasiccomponent[name=HiRTOScpuMultiCoreInterface, x=-3, y=-33.5]{HiRTOS\_Cpu\_Multi\_Core\_Interface}
               \end{umlpackage}
               \begin{umlpackage}{Platform Specific}
                  \umlbasiccomponent[name=HiRTOSPlatformParameters, x=3, y=-26]{HiRTOS\_Platform\_Parameters}
                  \umlbasiccomponent[name=HiRTOScpuArchInterfaceInterrupts, x=3, y=-28.5]{HiRTOS\_Cpu\_Interface.Interrupts}
                  \umlbasiccomponent[name=HiRTOSlowLevelDebugInterface, x=3, y=-31]{HiRTOS\_Low\_Level\_Debug\_Interface}
               \end{umlpackage}
            \end{umlpackage}

            \umlimport[]{HiRTOS API}{HiRTOS internals}
            \umlimport[]{HiRTOS internals}{GenericLinkedList}
            \umlimport[]{HiRTOS}{HiRTOS Porting Layer}
         \end{tikzpicture}
      }
   \end{center}
   \caption{HiRTOS Code Components}
   \label{HiRTOSAchitecture3}
\end{figure}

\clearpage
\section{HiRTOS Z Specification}

\subsection{HiRTOS Data Structures}

\subsubsection{Z Naming Conventions}
%\paragraph*{NOTE:}

The following naming conventions are used in the Z model of \emph{HiRTOS}:
\begin{itemize}
\item Z Primitive types are in uppercase.
\item Z Composite types (schema types) start with uppercase.
\item Z constants and variables start with lower case.
\item Identifiers that start with the $z$ prefix are meant to be modeling-only
      entities that do not physically correspond to code-level entities.
\end{itemize}

\subsubsection{\emph{HiRTOS} Configuration Parameters}

Constants defined here represent compile-time configuration parameters for
\emph{HiRTOS}.

\begin{axdef}
    maxNumThreads: \nat_1 \\
    maxNumMutexes: \nat_1 \\
    maxNumCondvars: \nat_1 \\
    maxNumTimers: \nat_1 \\
    numThreadPriorities: \nat_1 \\
    numTimerWheelSpokes: \nat_1 \\
\where
    maxNumThreads \geq 2 * numCpus
\also
    maxNumCondvars \geq maxNumThreads
\also
    maxNumTimers \geq maxNumThreads
\end{axdef}

The minimum number of threads that can be configured per CPU core is 2, which corresponds to the \emph{HiRTOS}
pre-defined threads: the idle thread and the tick timer thread. Each thread has a builtin timer, so the minimum number of timers that can be configured is $maxNumThreads$. Also, each thread
has a builtin condition variable, so the minimum number of condition variables that can be configured is $maxNumThreads$ as well.

\subsubsection{\emph{HiRTOS} Target Platform Parameters}

Constants defined here represent compile-time target platform parameters for
\emph{HiRTOS}.

\begin{axdef}
    numCpus: \nat_1 \\
    minMemoryAddress: \nat \\
    maxMemoryAddress: \nat_1 \\
    numInterruptPriorities: \nat_1 \\
    maxNumInterrupts: \nat_1 \\
\where
    minMemoryAddress < maxMemoryAddress
\end{axdef}

\subsubsection{\emph{HiRTOS} Primitive Types}
%
Below are the primitive types used in HiRTOS:

\begin{zed}
[CpuIdType] \\
\# CpuIdType = numCpus + 1 \\
[ThreadIdType] \\
\# ThreadIdType = maxNumThreads + 1 \\
[MutexIdType] \\
\# MutexIdType = maxNumMutexes + 1 \\
[CondvarIdType] \\
\# CondvarIdType = maxNumCondvars + 1 \\
[TimerIdType] \\
\# TimerIdType = maxNumTimers + 1 \\
[InterruptIdType] \\
\# InterruptIdType = maxNumInterrupts + 1 \\
\end{zed}

\begin{axdef}
   invalidCpuId : CpuIdType \\
   invalidThreadId : ThreadIdType \\
   invalidMutexId : MutexIdType \\
   invalidCondvarId : CondvarIdType \\
   invalidTimerId : TimerIdType \\
   invalidInterruptId : InterruptIdType \\
\end{axdef}

\begin{zed}
    [CpuRegistersType] \\
    ValidCpuIdType == CpuIdType \setminus \{ invalidCpuId \} \\
    MemoryAddressType == \\
    \t1 minMemoryAddress \upto maxMemoryAddress \\
    nullAddress == 0 \\
    ValidThreadIdType == \\
    \t1 ThreadIdType \setminus \{ invalidThreadId \} \\
    ValidMutexIdType == MutexIdType \setminus \{ invalidMutexId \} \\
    ValidCondvarIdType == \\
    \t1 CondvarIdType \setminus \{ invalidCondvarId \} \\
    ValidTimerIdType == TimerIdType \setminus \{ invalidTimerId \} \\
    ValidInterruptIdType == \\
    \t1 InterruptIdType \setminus \{ invalidInterruptId \} \\
    ThreadPriorityType == 0 \upto numThreadPriorities \\
    invalidThreadPriority == numThreadPriorities \\
    ValidThreadPriorityType == \\
    \t1 ThreadPriorityType \setminus \{ invalidThreadPriority \} \\
    InterruptPriorityType == 0 \upto numInterruptPriorities \\
    invalidInterruptPriority == numInterruptPriorities \\
    ValidInterruptPriorityType == \\
    \t1 InterruptPriorityType \setminus \{ invalidInterruptPriority \} \\
    AtomicLevelType == 0 \upto numInterruptPriorities + 1 \\
    atomicLevelNoInterrupts == min~AtomicLevelType \\
    atomicLevelSingleThread == max~AtomicLevelType - 1 \\
    atomicLevelNone == max~AtomicLevelType \\
    InterruptNestingCounterType == \\
    \t1 0 \upto numInterruptPriorities \\
    ActiveInterruptNestingCounterType == \\
    \t1 InterruptNestingCounterType \setminus \{~ 0 ~\} \\
    CpuInterruptMaskingStateType ::= \\
    \t1 cpuInterruptsEnabled | \\
    \t1 cpuInterruptsDisabled \\
    CpuPrivilegeType ::= cpuPrivileged | cpuUnprivileged \\
    MemoryProtectionStateType ::= \\
    \t1 memoryProtectionOn | memoryProtectionOff \\
    CpuExecutionModeType ::= \\
    \t1 cpuExecutingResetHandler | \\
    \t1 cpuExecutingInterruptHandler | \\
    \t1 cpuExecutingThread \\
    ThreadStateType ::= threadNotCreated | threadSuspended | \\
    \t5 threadRunnable | threadRunning | \\
    \t5 threadBlockedOnCondvar | threadBlockedOnMutex \\
    ThreadSchedulerStateType ::= \\
    \t1 threadSchedulerStopped | threadSchedulerRunning \\
\end{zed}

\begin{zed}
    ThreadQueueType == \iseq ValidThreadIdType \\
    MutexListType == \iseq ValidMutexIdType \\
    TimerWheelSpokeIndexType == \\
    \t1 0 \upto numTimerWheelSpokes \\
    invalidTimerWheelSpokeIndex == \\
    \t1 max~TimerWheelSpokeIndexType \\
    ValidTimerWheelSpokeIndexType == \\
    \t1 TimerWheelSpokeIndexType ~\setminus \\
    \t1 \{~ invalidTimerWheelSpokeIndex ~\} \\
    TimerKindType ::= periodicTimer | oneShotTimer \\
    TimerStateType ::= timerStopped | timerRunning \\
\end{zed}

For interrupts, lower priority values represent higher priorities. For threads, lower priority
values represent lower priorities.

\subsubsection{\emph{HiRTOS} Axiomatic Definitions}

\begin{axdef}
    zAddressRange : \\
    \t1 (MemoryAddressType \cross MemoryAddressType) \inj \\
    \t1 \finset_1 MemoryAddressType
\where
    \forall x, y : MemoryAddressType | \\
   \t1  (x, y) \in \dom zAddressRange @ \\
   \t1 x < y \land zAddressRange(x, y) = x \upto y
\end{axdef}

\begin{axdef}
   zCpuToISRstackAddressRange: \\
   \t1 ValidCpuIdType \inj \\
   \t1 (MemoryAddressType \cross MemoryAddressType) \\
\where
   \bigcap~\{~ i: ValidCpuIdType @ \\
     zAddressRange(zCpuToISRstackAddressRange(i)) ~\} = \emptyset
\also
   \forall i : \dom zCpuToISRstackAddressRange @ \\
      \# (zAddressRange(zCpuToISRstackAddressRange(i))) \geq 2
\end{axdef}

\begin{axdef}
   interruptPriorities: \\
   \t1 InterruptIdType \fun InterruptPriorityType
\end{axdef}
%\clearpage

\subsubsection{\emph{HiRTOS} State Variables}

The $HiRtos$ schema represents the multi-core RTOS state variables (internal data
structures). All HiRTOS objects such as threads, mutexes,
condition variables and software timers are statically allocated
internally by HiRTOS.

\begin{schema}{HiRtos}
    rtosCpuInstances: \\
    \t1 ValidCpuIdType \finj HiRtosCpuInstanceType \\
    zAllCreatedThreadInstances: \finset ThreadType \\
\where
    \# rtosCpuInstances \geq 1
\also
    \forall i : \dom rtosCpuInstances @ \\
\t1   (rtosCpuInstances(i)).cpuId = i
\also
    zAllCreatedThreadInstances = \\
\t1    \bigcup~\{~ i: ValidCpuIdType @ \\
\t2    \ran (rtosCpuInstances(i)).threads ~\}
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    \ran (rtosCpuInstances(i)).threads ~\} = \emptyset
\also
    \bigcap~\{~ thread: zAllCreatedThreadInstances @ \\
\t1    zAddressRange(thread.stack) ~\} = \emptyset
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    \ran (rtosCpuInstances(i)).mutexes ~\} = \emptyset
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    \ran (rtosCpuInstances(i)).condvars ~\} = \emptyset
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    \ran (rtosCpuInstances(i)).timers ~\} = \emptyset
\also
    %\bigcap~\{~ \bigcup~ \{~ t: zAllCreatedThreadInstances @ zAddressRange(t.stack) ~\} ~\} = \emptyset
    \bigcap~\{ t: zAllCreatedThreadInstances @ zAddressRange(t.stack) ~\} = \emptyset
\end{schema}

\subsubsection{Per-CPU HiRTOS Instance}

The state variables and internal data structures of each per-CPU \emph{HiRTOS} instance
are described below:

\begin{schema}{HiRtosCpuInstanceType}
    cpuId: CpuIdType \\
    currentCpuContext: CpuRegistersType \\
    threadSchedulerState: ThreadSchedulerStateType \\
    currentAtomicLevel: AtomicLevelType \\
    currentCpuExecutionMode: CpuExecutionModeType \\
    currentThreadId: ThreadIdType \\
    timerTicksSinceBoot: \nat \\
    idleThreadId: ValidThreadIdType \\
    tickTimerThreadId: ValidThreadIdType \\
    interruptNestingLevelStack: InterruptNestingLevelStackType \\
    threads: ValidThreadIdType \finj ThreadType \\
    mutexes: ValidMutexIdType \finj MutexType \\
    condvars: ValidCondvarIdType \finj CondvarType \\
    timers: ValidTimerIdType \finj TimerType \\
    runnableThreadsQueue : ThreadPriorityQueueType \\
    timerWheel: TimerWheelType \\
    zCpuInterruptMaskingState: CpuInterruptMaskingStateType \\
    zCpuPrivilege: CpuPrivilegeType \\
    zMemoryProtectionState: MemoryProtectionStateType \\
\where
    \{~ idleThreadId, tickTimerThreadId ~\} \subseteq \dom threads
\also
    tickTimerThreadId \neq idleThreadId
\also
    threadSchedulerState = threadSchedulerRunning \implies \\
    (\forall t: \ran (\{~ currentThreadId ~\} \ndres threads) @ \\
\t1    t.currentPriority < (threads(currentThreadId)).currentPriority)
\also
    zCpuInterruptMaskingState = cpuInterruptsEnabled \iff \\
\t1 currentAtomicLevel > atomicLevelNoInterrupts
\also
    zCpuInterruptMaskingState = cpuInterruptsDisabled \implies zCpuPrivilege = cpuPrivileged
\also
    currentAtomicLevel < atomicLevelNone \implies zCpuPrivilege = cpuPrivileged
\also
    \bigcap~\{~ t: \ran threads @ \{~ t.builtinCondvarId ~\} ~\} = \emptyset
\also
    \bigcap~\{~ t: \ran threads @ \{~ t.builtinTimerId ~\} ~\} = \emptyset
\also
    \forall t: \ran threads @ (t.id = (threads \inv)(t) \land \\
    (t.ownedMutexes \neq \emptyset \implies \\
     t.currentPriority = max~ \{~ m : \ran t.ownedMutexes @ (mutexes(m)).ceilingPriority ~\}))
\also
    \forall m: \ran mutexes @ m.id = mutexes\inv(m)
\also
    \forall c: \ran condvars @  c.id = condvars\inv(c)
\also
    \forall ti: \ran timers @ ti.id = timers\inv(ti)
\also
    \forall p: ValidThreadPriorityType @ \\
\t1    \forall threadId: \ran (runnableThreadsQueue.threadQueues(p)) @ \\
\t2    (threads(threadId)).currentPriority = p
\end{schema}

\begin{schema}{ThreadPriorityQueueType}
    threadQueues: \\
    \t1 ValidThreadPriorityType \inj ThreadQueueType \\
    waitingThreadsCount: \nat
\where
   waitingThreadsCount = \\
   \# (\bigcup ~\{~ p: ValidThreadPriorityType @ threadQueues(p) ~\})
\end{schema}

\begin{schema}{InterruptNestingLevelStackType}
       interruptNestingLevels: \\
    \t1 ActiveInterruptNestingCounterType \inj \\
    \t1 InterruptNestingLevelType \\
    currentInterruptNestingCounter: \\
    \t1 InterruptNestingCounterType \\
    zCpuId: ValidCpuIdType
\where
   \forall x: \dom interruptNestingLevels @ \\
\t1   (interruptNestingLevels(x)).interruptNestingCounter = x \\
\t1   \land \\
\t1   (interruptNestingLevels(x)).savedStackPointer \in \\
\t1        zAddressRange(zCpuToISRstackAddressRange(zCpuId))
\also
   \dom interruptNestingLevels = \\
   1 \upto currentInterruptNestingCounter
\end{schema}

\begin{schema}{InterruptNestingLevelType}
   interruptId : InterruptIdType \\
   interruptNestingCounter: ActiveInterruptNestingCounterType \\
   savedStackPointer: MemoryAddressType \\
   atomicLevel: AtomicLevelType \\
\where
   atomicLevel \leq interruptPriorities (interruptId)
\also

\end{schema}

\begin{schema}{TimerWheelType}
   wheelSpokesHashTable: \\
   \t1 ValidTimerWheelSpokeIndexType \fun \finset ValidTimerIdType \\
   currentWheelSpokeIndex: ValidTimerWheelSpokeIndexType
\where
    \forall i, j: ValidTimerWheelSpokeIndexType | i \neq j @ \\
    \t1 wheelSpokesHashTable(i) \cap wheelSpokesHashTable(j) = \emptyset
\end{schema}

\begin{schema}{TimerType}
   id : TimerIdType \\
   timerKind : TimerKindType \\
   timerState : TimerStateType \\
   timerWheelRevolutions : \nat \\
   timerWheelRevolutionsLeft : \nat \\
   expirationCallbackAddr : MemoryAddressType \\
   wheelSpokeIndex : TimerWheelSpokeIndexType
\where
   timerWheelRevolutionsLeft \leq timerWheelRevolutions
\also
   timerState = timerRunning \implies expirationCallbackAddr \neq nullAddress
\end{schema}

\begin{schema}{ThreadType}
   id : ThreadIdType \\
   state : ThreadStateType \\
   currentPriority : ThreadPriorityType \\
   basePriority : ThreadPriorityType \\
   atomicLevel : AtomicLevelType \\
   builtinTimerId : TimerIdType \\
   builtinCondvarId : CondvarIdType \\
   waitingOnCondvarId : CondvarIdType \\
   waitingOnMutexId : MutexIdType \\
   ownedMutexes : \iseq ValidMutexIdType \\
   savedStackPointer : MemoryAddressType \\
   stack : AddressRangeType \\
   stackSavedCpuContext : CpuRegistersType \\
   privilegedNestingCounter : \nat \\
   timeSliceLeftUs : \nat
\where
   state \neq threadNotCreated \implies \\
   \t1 (id \neq invalidThreadId \land \\
   \t1 builtinTimerId \neq invalidTimerId \land \\
   \t1 builtinCondvarId \neq invalidCondvarId \land \\
   \t1 basePriority \neq invalidThreadPriority \land \\
   \t1 currentPriority \neq invalidThreadPriority \land \\
   \t1 savedStackPointer \in zAddressRange(stack))
\also
   currentPriority \geq basePriority
\also
   state = threadBlockedOnCondvar \iff \\
   \t1 waitingOnCondvarId \neq invalidCondvarId
\also
   state = threadBlockedOnMutex \iff \\
   \t1  waitingOnMutexId \neq invalidMutexId
\also
   waitingOnCondvarId \neq invalidCondvarId \implies \\
   \t1 waitingOnMutexId = invalidMutexId
\also
   waitingOnMutexId \neq invalidMutexId \implies \\
   \t1 waitingOnCondvarId = invalidCondvarId
\also
   waitingOnMutexId \notin \ran ownedMutexes
\end{schema}

\begin{schema}{CondvarType}
   id : CondvarIdType \\
   wakeupAtomicLevel : AtomicLevelType \\
   wakeupMutexId : MutexIdType \\
   waitingThreadsQueue : ThreadPriorityQueueType
\where
   wakeupAtomicLevel \neq atomicLevelNone \implies wakeupMutexId = invalidMutexId
\end{schema}

\begin{schema}{MutexType}
   id : MutexIdType \\
   ownerThreadId : ThreadIdType \\
   recursiveCount : \nat \\
   ceilingPriority : ThreadPriorityType \\
   waitingThreadsQueue : ThreadPriorityQueueType
\where
   waitingThreadsQueue.waitingThreadsCount \neq 0 \implies \\
   \t1 ownerThreadId \neq invalidThreadId
\also
   ceilingPriority \neq invalidThreadPriority \implies \\
   (\forall p: ValidThreadPriorityType | \\
   \t1     waitingThreadsQueue.threadQueues(p) \neq \emptyset @ \\
   \t1     p \leq ceilingPriority)
\end{schema}

\subsection{HiRTOS Boot-time Initialization}

When \verb`HiRTOS.Initialize` is called for each CPU core, the idle thread
and the tick timer thread for that CPU are created, but the thread
scheduler is not started yet:

\begin{schema}{HiRtosInitialize}
   HiRtos' \\
   HiRtosCpuInstanceInitialize \\
   cpuId? : CpuIdType \\
\where
   cpuId' = cpuId?
\also
   \theta HiRtosCpuInstanceType' = rtosCpuInstances'(cpuId?)
\also
   interruptNestingLevelStack'.zCpuId = cpuId?
\end{schema}

\begin{schema}{HiRtosCpuInstanceInitialize}
   HiRtosCpuInstanceElaboration
\where
    idleThreadId' \neq invalidThreadId
\also
    tickTimerThreadId' \neq invalidThreadId
\also
    tickTimerThreadId' \neq idleThreadId'
\also
    \dom threads' = \{~ idleThreadId', tickTimerThreadId' ~\}
\also
    \dom condvars' = \\
   \{~ (threads'(idleThreadId')).builtinCondvarId, \\
      (threads'(tickTimerThreadId')).builtinCondvarId ~\}
\also
    \dom timers' = \\
   \{~ (threads'(idleThreadId')).builtinTimerId, \\
       (threads'(tickTimerThreadId')).builtinTimerId ~\}
\also
    zCpuInterruptMaskingState' = cpuInterruptsEnabled
\also
    zCpuPrivilege' = cpuUnprivileged
\also
    zMemoryProtectionState' = memoryProtectionOn
\also
    runnableThreadsQueue'.threadQueues(min~ ValidThreadPriorityType) \\
    \t1 = \langle idleThreadId' \rangle
\also
    runnableThreadsQueue'.threadQueues(max~ ValidThreadPriorityType) \\
    \t1 = \langle tickTimerThreadId' \rangle
\also
   \forall p : ValidThreadPriorityType \setminus \\
   \t2   \{~ min~ ValidThreadPriorityType, max~ ValidThreadPriorityType ~\} @ \\
   \t1 runnableThreadsQueue'.threadQueues(p) = \emptyset
\end{schema}

\begin{schema}{HiRtosCpuInstanceElaboration}
    HiRtosCpuInstanceType' \\
    InterruptNestingLevelStackElaboration
\where
    threadSchedulerState' = threadSchedulerStopped
\also
    currentThreadId' = invalidThreadId
\also
    currentAtomicLevel' = atomicLevelNone
\also
    currentCpuExecutionMode' = cpuExecutingResetHandler
\also
    idleThreadId' = invalidThreadId
\also
    tickTimerThreadId' = invalidThreadId
\also
    threads' = \emptyset
\also
    condvars' = \emptyset
\also
    timers' = \emptyset
\also
    timerTicksSinceBoot' = 0
\end{schema}

\begin{schema}{InterruptNestingLevelStackElaboration}
   InterruptNestingLevelStackType' \\
   InterruptNestingLevelElaboration
\where
   currentInterruptNestingCounter' = 1 \\
\also
   \forall x: ActiveInterruptNestingCounterType @ \\
\t1   interruptNestingLevels'(x) = \theta InterruptNestingLevelType' \\
\end{schema}

\begin{schema}{InterruptNestingLevelElaboration}
   InterruptNestingLevelType'
\where
   interruptId' = invalidInterruptId
\also
   interruptNestingCounter' = 0
\also
   savedStackPointer' = nullAddress
\also
   atomicLevel' = atomicLevelNone
\end{schema}

\begin{schema}{TimerWheelElaboration}
   TimerWheelType'
\where
   \ran wheelSpokesHashTable' = \{~ \emptyset ~\}
\also
   currentWheelSpokeIndex' = \\
   \t1 min~ValidTimerWheelSpokeIndexType
\end{schema}

\subsection{HiRTOS Callable Services}

\subsubsection{\emph{HiRTOS} Mutex Operations}

\paragraph{Create a new mutex}

A mutex can be created by calling \verb`HiRTOS.Mutex.Create`. Mutexes are allocated from a pool of
mutex objects shared among all CPU cores:

\begin{schema}{CreateMutex}
   \Delta HiRtosType \\
   \Delta HiRtosCpuInstanceType \\
   InitializeNewMutex \\
   cpuId? : CpuIdType \\
\where
   \theta HiRtosCpuInstanceType = rtosCpuInstances(cpuId?)
\also
   \theta HiRtosCpuInstanceType' = rtosCpuInstances'(cpuId?)
\also
   \theta MutexType' = createdMutexInstances'(mutexId!)
\also
   mutexId! \notin \dom createdMutexInstances
\also
   mutexId! \notin \dom mutexes
\also
   mutexId! \in \dom createdMutexInstances'
\also
   mutexes'(mutexId!) = createdMutexInstances'(mutexId!)
\end{schema}

\begin{schema}{InitializeNewMutex}
   \Delta MutexType \\
   ceilingPriority? : ThreadPriorityType \\
   mutexId! : ValidMutexIdType
\where
   mutexId! \neq invalidMutexId
\also
   id' = mutexId!
\also
   ceilingPriority' = ceilingPriority?
\end{schema}

If $ceilingPriority?$ is $invalidThreadPriority$ that means that the mutex follows the priority
inheritance protocol. Otherwise, it follows the priority ceiling protocol. In the priority inheritance
protocol, if the thread trying to acquire a busy mutex has higher priority than the thread currently
owning the mutex, the owning thread gets its priority raised to the priority of the waiting thread.
In the priority ceiling protocol, when a thread acquires a mutex, if the mutex's ceiling priority is
higher than the thread's priority, the thread gets its priority raised to the ceiling priority.

The $CreatedMutexMutableOperation$ schema below is used in the specifications of all the mutable
operations that can be performed on mutexes that were previously created by a call to
\verb'HiRTOS.Mutex.Create':

\begin{schema}{CreatedMutexMutableOperation}
   \Delta HiRtosType \\
   \Delta HiRtosCpuInstanceType \\
   \Delta MutexType \\
   cpuId? : CpuIdType \\
   mutexId? : ValidMutexIdType
\where
   \theta HiRtosCpuInstanceType = rtosCpuInstances(cpuId?)
\also
   \theta HiRtosCpuInstanceType' = rtosCpuInstances'(cpuId?)
\also
   \theta MutexType = mutexes(mutexId?)
\also
   \theta MutexType' = mutexes'(mutexId?)
\end{schema}

\subsubsection{Acquire a mutex}

A thread acquires a mutex by calling \verb`HiRTOS.Mutex.Acquire`, according to the contract
specified by the $AcquireMutex$ schema:

\begin{schema}{AcquireAvailableMutex}
   CreatedMutexMutableOperation
\where
   ownerThreadId = invalidThreadId
\also
   ownerThreadId' = currentThreadId
\also
(ceilingPriority \neq invalidThreadPriority \land \\
 (threads(currentThreadId)).currentPriority < \\
 \t1    ceilingPriority) \implies \\
 (threads'(currentThreadId)).currentPriority = \\
 \t1    ceilingPriority
\end{schema}

\begin{schema}{WaitOnUnavailableMutex}
   CreatedMutexMutableOperation
\where
   ownerThreadId \neq invalidThreadId
\also
(\LET oldCurrentPriority == \\
\t1 (threads(currentThreadId)).currentPriority @ \\
(ceilingPriority = invalidThreadPriority \land \\
 oldCurrentPriority > \\
 \t1 (threads(ownerThreadId)).currentPriority) \implies \\
 (threads'(ownerThreadId)).currentPriority = \\
 \t1 oldCurrentPriority \\
\land \\
 currentThreadId' \neq ownerThreadId \implies \\
 ((threads'(currentThreadId')).currentPriority \geq \\
 \t1 (threads'(ownerThreadId)).currentPriority \lor \\
 (threads'(ownerThreadId)).state = threadBlocked) \\
\land \\
   currentThreadId \in \\
\ran (waitingThreadsQueue'.threadQueues(oldCurrentPriority)))
\end{schema}

\begin{zed}
   AcquireMutex \defs \\
   \t1 AcquireAvailableMutex \lor WaitOnUnavailableMutex
\end{zed}

%\bibliographystyle{ieeetr}
%\bibliography{bibliography}
%\balance

\begin{thebibliography}{9}

\bibitem{Zrm}
Mike Spivey, ``The Z Reference Manual'', second edition, Prentice-Hall, 1992 \\
\url{http://spivey.oriel.ox.ac.uk/~mike/zrm/zrm.pdf}

\bibitem{WayofZ}
Jonathan Jacky, ``The Way of Z'', Cambridge Press, 1997 \\
\url{http://staff.washington.edu/jon/z-book/index.html}

\bibitem{Fuzz}
Mike Spivey, ``The Fuzz checker'' \\
\url{http://spivey.oriel.ox.ac.uk/mike/fuzz}

\bibitem{SparkAda}
John W. McCormick, Peter C. Chapin,``Building High Integrity Applications with SPARK'', Cambridge University Press, 2015 \\
\url{https://www.amazon.com/Building-High-Integrity-Applications-SPARK/dp/1107040736}

\bibitem{gnatprove}
AdaCore,``Formal Verification with GNATprove'' \\
\url{https://docs.adacore.com/spark2014-docs/html/ug/en/gnatprove.html}

\bibitem{libcThreads}
ISO, ``N2731: Working draft of the C23 standard, section 7.26'', October 2021 \\
\url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2596.pdf#page=345&zoom=100,102,113}

\bibitem{prioCeiling}
Lui Sha et al, ``Priority Inheritance Protocols: An Approach to Real-Time Synchronization'', IEEE Transactions on Computers, September 1990 \\
\url{https://www.csie.ntu.edu.tw/~r95093/papers/Priority%20Inheritance%20Protocols%20An%20Approach%20to%20Real-Time%20Synchronization.pdf}

\bibitem{SepK}
John Rushby, ``Design and Verification of Secure Systems'', ACM SIGOPS Operating Systems Review, 1981 \\
\url{https://www.csl.sri.com/users/rushby/papers/sosp81.pdf}

\bibitem{freeRTOS}
FreeRTOS
\url{https://www.freertos.org/}

\bibitem{cmsisRTOS}
CMSIS-RTOS API v2 (CMSIS-RTOS2)
\url{https://www.keil.com/pack/doc/CMSIS/RTOS2/html/group__CMSIS__RTOS.html}

\end{thebibliography}

\end{document}
