\documentclass[11pt,letterpaper,twoside,openany]{book}
%\usepackage{lineno}
%\usepackage{afterpage}
\usepackage[pdftex]{graphicx}
\usepackage[pdftex, pdfborder={0 0 0}]{hyperref}
\usepackage[pdftex]{lscape}
\usepackage{listings}
%\usepackage{longtable}
%\usepackage{fancyvrb}
\usepackage{zed-csp}

\lstset{language=Ada,
        basicstyle=\small}

\addtolength{\textheight}{0.6in}
%\addtolength{\textheight}{1.25in}

\addtolength{\textwidth}{0.6in}
%\addtolength{\textwidth}{0.5in}

%\setlength{\parskip}{5pt plus1pt minus1pt}
%\addtocounter{secnumdepth}{1}

\pagestyle{plain}
%\linenumbers

\begin{document}
\title{Design of the HiRTOS Multi-core \\
       Real-Time Operating System}
\author{Germ\'an Rivera \\
        \texttt jgrivera67@gmail.com}
\date{\today}
\maketitle

\frontmatter
\tableofcontents
%\listoffigures

\mainmatter
\raggedbottom
\pagestyle{myheadings}
\markboth{Design of the HiRTOS Multi-core Real-Time Operating System}{Design of the HiRTOS Real-Time Operating System}

\chapter{HiRTOS: A High Integrity RTOS}

This document describes the design of \emph{HiRTOS}, a high integrity real-time
operating system kernel that supports multi-core systems. The design is presented using the
\href{http://en.wikipedia.org/wiki/Z_notation}{Z notation} \cite{Zrm, WayofZ}.
Z is a software modeling notation based on discrete mathematics structures (such as sets,
relations and functions) and predicate logic. With Z, data structures can be specified in
terms of mathematical structures and their state invariants can be specified using mathematical
predicates. The pre-conditions and post-conditions of the operations that manipulate
the data structures can also be specified using predicates. Using Z for this purpose encourages
a rigorous and methodical thought process to elicit correctness properties, in a systematic way.
The HiRTOS Z model described here was checked with the \verb'fuzz' tool~\cite{Fuzz}, a
Z type-checker, that catches Z type mismatches in predicates.

\section{Z Naming Conventions}
%\paragraph*{NOTE:}

The following naming conventions are used in the Z model of HiRTOS:
\begin{itemize}
\item Z Primitive types are in uppercase.
\item Z Composite types (schema types) start with uppercase.
\item Z constants and variables start with lower case.
\item Identifiers that start with the $z$ prefix are model-only variables
      that are not meant to be implemented in code.
\end{itemize}

\section{Major Design Decisions}

\begin{itemize}
\item ISRs are seen as hardware-scheduled threads that have higher priority than all
software-scheduled threads. They always run in privileged mode and can only be preempted by
higher-priority ISRs. They cannot block waiting on mutexes or condition variables.

\item For API simplicity, inspired by the thread synchronization primitives of the C11 standard
library \cite{libcThreads}, mutexes and condition variables are the only real synchronization
primitives in HiRTOS.
Other synchronization primitives such as semaphores, event flags and message queues can be
implemented on top of them.

\item Unlike stadanrd mutexes, HiRTOS mutexes have priorities to support the priority ceiling
protocol \cite{prioCeiling}.

\item HiRTOS atomic levels can be used to disable the thread scheduler or to disable interrupts
at and below a given priority or to disable all interrupts.

\item In a multi-core platform, there is one HiRTOS instance per CPU Core. Each HiRTOS instance is
independent of each other. No resources are shared between HiRTOS instances. No communication between
CPU cores is supported by HiRTOS, so that the HiRTOS API can stay the same for both single-core
and multi-core platforms. Inter-core communication would need to be provided outside of HiRTOS,
using doorbell interrupts and mailboxes or shared memory, for example.

\item
Threads are bound to the CPU core in which they were created, for the lifetime of the thread. That is,
no thread migration between CPU cores is supported.

\item
All RTOS objects such as threads, mutexes and condition variables are allocated internally
by HiRTOS from statically allocated internal object pools.
These object pools are just RTOS-private global arrays of the corresponding RTOS object types,
sized at compile time via configuration parameters, whose values are application-specific.
RTOS object handles provided to application code are just indices into these internal object arrays.
No actual RTOS object pointers exposed to application code.
No dynamic allocation/deallocation of RTOS objects is supported and no static allocation of RTOS
objects in memory owned by application code is supported either.

\item
All application threads run in unprivileged mode. For each thread, the only writable memory,
by default is its own stack. Global variables in application code are read-only by default.
To be able to write global variables, application code must request write permission to
HiRTOS via a system call. MMIO space is not accessible by default. Application (or driver)
code must request access (read-only or read-write permission) to HiRTOS via a system call.
\end{itemize}

\clearpage
\section{HiRTOS Configuration Parameters}

Constants defined here represent compile-time configuration parameters for
HiRTOS.

\begin{axdef}
    maxNumThreads: \nat_1 \\
    maxNumMutexes: \nat_1 \\
    maxNumCondvars: \nat_1 \\
    maxNumTimers: \nat_1 \\
    numThreadPriorities: \nat_1 \\
\where
    maxNumThreads > 2
\end{axdef}

The minimum number of threads that can be configured is 2, which corresponds to the HiRTOS pre-defined threads:
the idle thread and the tick timer thread.

\section{HiRTOS Target Platform Parameters}

Constants defined here represent compile-time target platform parameters for
HiRTOS.

\begin{axdef}
    maxNumCpus: \nat_1 \\
    minMemoryAddress: \nat \\
    maxMemoryAddress: \nat_1 \\
    numInterruptPriorities: \nat_1 \\
\where
    minMemoryAddress < maxMemoryAddress
\end{axdef}

\section{HiRTOS Primitive Types}

\begin{zed}
    CpuIdType == 0 \upto maxNumCpus - 1 \\
    MemoryAddressType == minMemoryAddress \upto maxMemoryAddress \\
    ThreadIdType == 0 \upto maxNumThreads \\
    invalidThreadId == maxNumThreads \\
    idleThreadId == 0 \\
    tickTimerThreadId == 1 \\
    ValidThreadIdType == ThreadType \setminus \{ InvalidThreadId \} \\
    ThreadPrioirtyType == 0 \upto numThreadPriorities \\
    invalidThreadPriority == numThreadPriorities \\
    ValidThreadPriorityType == ThreadPriorityType \setminus \{ InvalidThreadPriority \} \\
    MutexIdType == 0 \upto maxNumMutexes \\
    invalidMutexId == maxNumMutexes \\
    ValidMutexIdType == MutexType \setminus \{ InvalidMutexId \} \\
    CondvarIdType == 0 \upto maxNumCondvars \\
    invalidCondvarId == maxNumCondvars \\
    ValidCondvarIdType == CondvarType \setminus \{ InvalidCondvarId \} \\
    TimerIdType == 0 \upto maxNumTimers \\
    invalidTimerId == maxNumTimers \\
    ValidTimerIdType == TimerType \setminus \{ InvalidTimerId \} \\
    InterruptPrioirtyType == 0 \upto numInterruptPriorities \\
    invalidInterruptPriority == numInterruptPriorities \\
    ValidInterruptPriorityIdType == InterruptPriorityType \setminus \{ InvalidInterruptPriorityId \} \\
    AtomicLevelType == 0 \upto numInterruptPriorities + 1 \\
    atomicLevelNoInterrupts == min~AtomicLevelType \\
    atomicLevelSingleThread == max~AtomicLevelType - 1 \\
    atomicLevelNone == max~AtomicLevelType \\
    CpuInterruptMaskingStateType ::= cpuInterruptsEnabled | cpuInterruptsDisabled \\
    CpuPrivilegeType ::= cpuPrivileged | cpuUnprivileged \\
    MemoryProtectionStateType ::= memoryProtectionOn | memoryProtectionOff \\
    CpuExecutionModeType ::= cpuExecutingResetHandler | cpuExecutingInterruptHandler | cpuExecutingThread \\
    ThreadStateType ::= threadNotCreated | threadRunnable | threadRunning | threadInterrupted | threadBlocked \\
    HiRtosStateType ::= threadSchedulerStopped | threadSchedulerRunning \\
    TimerTicksType == \nat \\
    ThreadQueueType == \iseq ValidThreadIdType \\
    MutexListType == \iseq ValidMutexIdType \\
    MutexListType == \iseq ValidMutexIdType \\
    TimerListType == \iseq ValidTimerIdType \\
\end{zed}

For interrupts, lower priority values represent higher priorities. For threads, lower priority
values represent lower priorities.

\section{Per-CPU HiRTOS State Variables}

There is a separate HiRTOS instance per CPU core in the target platform:

\begin{axdef}
    hiRtosInstances: CpuIdType \inj HiRtosInstanceType \\
\where
    \forall cpuId: \dom hiRtosInstances @ hiRtosInstances(cpuId).cpuId = cpuId
\end{axdef}

The state variables and internal data structures of each HiRTOS instance are modeled by the $HiRtosInstanceType$
state space schema:

\begin{schema}{HiRtosInstanceType}
    cpuId: CpuIdType \\
    threadSchedulerState: ThreadSchedulerStateType \\
    currentAtomicLevel: AtomicLevelType \\
    currentPrivilegeNestingCounter: PrivilegeNestingCounterType \\
    currentThreadId: ThreadIdType \\
    timerTicksSinceBoot: TimerTicksType \\
    threadInstances: ValidThreadIdType \pinj ThreadType \\
    mutexInstances: ValidMutexIdType \pinj MutexType \\
    condvarInstances: ValidCondvarIdType \pinj CondvarType \\
    timerInstances: ValidTimerIdType \pinj TimerType \\
    interruptNestingLevelStack: InterruptNestingLevelStackType \\
    runnableThreadQueues: ValidThreadPriorityIdType \inj ThreadQueueType \\
    timerWheel: TimerWheelType \\
    zCpuInterruptMaskingState: CpuInterruptMaskingStateType \\
    zCpuPrivilege: CpuPrivilegeType \\
    zCpuExecutionMode: CpuExecutionModeType \\
    zMemoryProtectionState: MemoryProtectionStateType \\
\where
	threadSchedulerState = ThreadSchedulerRunning \implies currentThreadId \in \dom threadInstances
\also
    zCpuInterruptMaskingState = cpuInterruptsEnabled \iff currentAtomicLevel > AtomicLevelNoInterrupts
\also
    zCpuInterruptMaskingState = cpuInterruptsDisabled \implies zCpuPrivilege = cpuPrivileged
\also
    currentAtomicLevel < AtomicLevelNone \implies zCpuPrivilege = cpuPrivileged
\also
    currentPrivilegeNestingCounter > 0 \iff zCpuPrivilege = cpuPrivileged
\also
    zCpuExectionMode \neq cpuExecutingThread \implies zCpuPrivilege = cpuPrivileged
\end{schema}

%\clearpage
\subsection{Per-CPU HiRTOS Initialization}

After calling the \verb$HiRTOS.Initialize$ HiRTOS API, on a given CPU core, the state of the
corresponding HiRTOS instance is as described below:

\begin{schema}{HiRtosInitialize}
    HiRtosInstanceType' \\
    zCpuId?: CpuIdType \\
\where
    cpuId' = zCpuId?
\also
    threadSchedulerState' = threadSchedulerStopped \\
\also
    currentAtomicLevel' = AtomicLevelNone \\
\also
    currentPrivilegeNestingCounter' = 1 \\
\also
    currentThreadId' = InvalidThreadId \\
\also
    timerTicksSinceBoot' = 0 \\
\also
    \dom threadInstances' = \{ idleThreadId, tickTimerThreadId \} \\
\also
    mutexInstances' = \emptyset \\
\also
    condvarInstances' = \emptyset \\
\also
    timerInstances' = \emptyset \\
\also
    \theta interruptNestingLevelStack' = \theta InitInterruptNestingLevelStack \\
\also
    \theta timerWheel' = \theta InitTimerWheel \\
\also
    zCpuInterruptMaskingState' = cpuInterruptsEnabled \\
\also
    zCpuPrivilege' = cpuPrivileged \\
\also
    zMemoryProtectionState' = memoryProtectionOn \\
\also
    zCpuExecutionMode' = cpuExecutingResetHandler \\
\also
    runnableThreadQueues'(min~ ValidInterruptPriorityIdType) = \langle idleThreadId \rangle \\
\also
    runnableThreadQueues'(max~ ValidInterruptPriorityIdType) = \langle tickTimerThreadId \rangle \\
\also
     \forall p: ValidThreadPrioirtyType \setminus
            \{ \min~ValidThreadPrioirtyType, \max~ValidThreadPrioirtyType \} @ \\
\t1      runnableThreadQueues'(p) = \emptyset
\end{schema}

%\clearpage
\subsection{Starting the Per-CPU HiRTOS Thread Scheduler}

After calling the \verb$HiRTOS.Start_Thread_Scheduler$ HiRTOS API, on a given CPU core, RTOS multi-tasking
is started on the given CPU, as described below:

\begin{schema}{HiRtosStartThreadScheduler}
    \Delta HiRtosInstanceType \\
    zCpuId?: CpuIdType \\
\where
\end{schema}

\subsection{Entering HiRTOS from Interrupt Context}

After calling the \verb$HiRTOS.Enter_Interrupt_Context$ HiRTOS API, from an ISR on a given CPU core, RTOS multi-tasking
the HiRTOS environment for interrupt context is entered.

\begin{schema}{HiRtosEnterInterruptContext}
    \Delta HiRtosInstanceType \\
    zCpuId?: CpuIdType \\
    zInterruptId?: InterruptIdType \\
\where
\end{schema}

\subsection{Exiting HiRTOS from Interrupt Context}

After calling the \verb$HiRTOS.Exit_Interrupt_Context$ HiRTOS API, from an ISR on a given CPU core, RTOS multi-tasking
the HiRTOS environment for interrupt context is exited.

\begin{schema}{HiRtosExitInterruptContext}
    \Delta HiRtosInstanceType \\
    zCpuId?: CpuIdType \\
    zInterruptId?: InterruptIdType \\
\where
\end{schema}

???
\clearpage
\subsection{CPU Controllers}

\begin{schema}{CpuController}
	ThreadScheduler \\
    cpuId: CpuIdType \\
    zExecutionContexts: \finset_1 ExecutionContext \\
    preemptedBy: ExecutionContext \pinj ExecutionContext \\
    timers: \finset Timer \\
  	zIterruptChannelToInterrupt: INTERRUPT\_CHANNEL \inj Interrupt \\
    interrupts: \finset_1 Interrupt \\
    tickTimerInterrupt: Interrupt \\
    runningExecutionContext: ExecutionContext \\
    nestedInterruptCount: 0 \upto kMaxNumInterruptChannelsPerCpu \\
	activeInterruptsBitMap: \finset INTERRUPT\_CHANNEL \\
    activeInterrupts: \finset Interrupt \\
\where
	 \ran zIterruptChannelToInterrupt = interrupts
\also
     zExecutionContexts = \\
\t1     \{ t: threads @ t.executionContext \} \cup \{ i: interrupts @ i.executionContext \}
\also
     \{ t: threads @ t.executionContext \} \cap \{ i: interrupts @ i.executionContext \} = \emptyset
\also
     \forall et: zExecutionContexts @ et.cpuId = cpuId
\also
	 activeInterrupts = \{ iv: activeInterruptsBitMap @ zIterruptChannelToInterrupt(iv) \}
\also
     nestedInterruptCount = \# activeInterrupts
\also
	 nestedInterruptCount = 0 \iff \\
\t1 	runningExecutionContext \in \{ t: zRunnableThreads @ t.executionContext \}
\also
     nestedInterruptCount > 0 \iff \\
\t1		runningExecutionContext \in \{ i: activeInterrupts @ i.executionContext \}
\end{schema}

Invariants:
\begin{itemize}
\item There can be more than one interrupt with the same interrupt priority. Interrupt
    scheduling is done by hardware, by the interrupt controller.
\item The same interrupt cannot be nested.
\end{itemize}

$ThreadScheduler$ represents the state variables of the Per-CPU thread scheduler.

\clearpage
\begin{schema}{ThreadScheduler}
 	zThreadIdToThread: THREAD\_ID \pinj Thread \\
    threads: \finset_1 Thread \\
    zUserThreads: \finset Thread \\
    zSystemThreads: \finset_1 Thread \\
    idleThread: Thread \\
    runningThread: Thread \\
    runnableThreadPrioritiesBitMap: \finset_1 THREAD\_PRIO \\
    runnableThreadQueues: THREAD\_PRIO \inj ThreadQueue \\
    zRunnableThreads: \finset_1 Thread \\
\where
     \ran zThreadIdToThread = threads
\also
	 zRunnableThreads = \\
\t1 \bigcup \{ i: THREAD\_PRIO @ \ran (runnableThreadQueues(i)).zElements \}
\also
     zRunnableThreads \neq \emptyset \land zRunnableThreads \subseteq threads
\also
     threads = zUserThreads \cup zSystemThreads
\also
     zUserThreads \cap zSystemThreads = \emptyset
\also
     \forall t: zSystemThreads @ t.executionContext.cpuPrivilege = cpuPrivileged
\also
     \forall t: zUserThreads @ \\
\t1      t.executionContext.contextType = threadContext
\also
     idleThread \in zSystemThreads
\also
	 zThreadIdToThread(0) = idleThread
\also
     runningThread \in zRunnableThreads \land runningThread.state = kRunning
\also
     \forall t: zRunnableThreads \setminus \{ runningThread \} @ t.state = kRunnable
\also
     \forall t: threads \setminus zRunnableThreads @ \\
\t1     t.state \notin \{kRunnable, kRunning \}
\also
	\ran (runnableThreadQueues(kLowestThreadPriority)).zElements = \{ idleThread \}
\also
  	\forall t: threads @ \\
\t1 	runningThread.currentPriority \geq t.currentPriority
\also
  	\forall prio: runnableThreadPrioritiesBitMap @ prio \in \dom runnableThreadQueues
\end{schema}

Invariants:
\begin{itemize}
\item The running thread is always the highest priority thread. There can be more than one
thread with the same thread priority. Threads of equal priority are time-sliced in a
round-robin fashion.
\item Each CPU has an idle thread. The idle thread has the lowest priority and cannot get
blocked on any mutex or condvar, but it is the only thread that can execute an instruction
that stops the processor until an interrupt happens.
\end{itemize}

\begin{schema}{ThreadQueue}
    GenericLinkedList[Thread] \\
\end{schema}

\clearpage
\subsection{ExecutionContext}

\begin{schema}{ExecutionContext}
    cpuRegisters: CpuRegisterIdType \inj CpuRegisterValueType \\
    stackPointer: MemoryAddressType \\
    cpuId: CpuIdType \\
    cpuPrivilege: CpuPrivilegeType \\
    contextType: ExecutionContextType \\
    exeStackTopEnd: MemoryAddressType \\
    exeStackBottomEnd: MemoryAddressType \\
 \where
    stackPointer \in cpuRegisters
\also
    kWordValue(stackPointer) \in \dom executionStack
\also
    exeStackTopEnd < exeStackBottomEnd
\also
    exeStackTopEnd \upto exeStackBottomEnd \subset kValidRamWordAddresses
\also
    \dom executionStack = exeStackTopEnd + 1 \upto exeStackBottomEnd
\also
	\dom executionStack \subset kValidRamWordAddresses
\also
	\dom executionStack \cap kReadOnlyAddresses = \emptyset
\end{schema}


\subsection{Threads}

\begin{schema}{Thread}
    executionContext: ExecutionContext \\
    threadID: THREAD\_ID \\
    threadFunction: kExecutableAddresses \\
    state: THREAD\_STATE \\
	basePriority: THREAD\_PRIO \\
	currentPriority: THREAD\_PRIO \\
    listNode: LIST\_NODE \\
    deadlineToRun: \nat \\
\where
	currentPriority \geq basePriority
\also
	executionContext.contextType = kThreadContext
\also
    \# executionContext.executionStack = kThreadStackSizeInWords
\end{schema}

User-created threads run in the CPU's unprivileged mode and system internal threads run in the CPU's privileged mode.
This is to prevent user threads to execute privileged instructions. If a
user thread needs to execute a provileged instruction, it needs to first switch the CPU to privileged mode.

Invariants:
\begin{itemize}
\item The current priority of a thread can never be lower than its base priority. The
current priority can be higher than the base priority when it acquires a mutex that has
higher priority than the thread's base priority.
\item A thread never gets blocked trying to acquire a mutex that has the same priority
as the thread. Still, the thread needs to acquire the mutex, since other threads with
the same prioirity may also try to acquire the same mutex, if the running thread gets
switched out due running out of its time slice.
\item A thread should never try to acquire a mutex of lower priority than the thread's priority. Indeed, It does not need to, as it cannot be preemted by lower priority threads.
\end{itemize}

\subsection{Interrupts}

\begin{schema}{Interrupt}
    executionContext: ExecutionContext \\
    interruptChannel: INTERRUPT\_CHANNEL \\
	isrFunction: kExecutableAddresses \\
\where
	executionContext.contextType = kInterruptContext
\also
	executionContext.cpuPrivilege = cpuPrivileged
\also
    \# executionContext.executionStack = kInterruptStackSizeInWords
\end{schema}

Interrupt execution contexts run in privileged mode. To ensure that a higher
priority interrupt is not delayed by a lower priority interrupt, nested
interrupts are supported. To this end, interrupt service routines (ISRs)
run with interrupts enabled by default. However, interrupts with the same or
lower priority cannot interrupt the CPU until we finish servicing the current
interrupt, as the interrupt controller is expected to only raise interrupts
with higher priority than the current one being serviced. (The last step in
servicing an interrupt is to notify the interrupt controller of the
completion of servicing the interrupt).

\subsection{Timers}

\begin{schema}{Timer}
    counter: \nat \\
%\where
\end{schema}

%\clearpage

\subsection{Mutexes}

\begin{schema}{Mutex}
	waitingThreads: ThreadQueue \\
    synchronizationScope: SynchronizationScopeType \\
    priority: MutexPriorityType \\
\end{schema}

HiRTOS mutexes implement the priority ceiling protocol. That is, each mutex has a priority
associated with it, which is the priority of the highest priority task that accesses the
resource protected by the mutex, or the lowest interrupt priorirty, in case if an ISR
accesses the resource protected by the mutex.
The mutex is supposed be acquired by threads that have lower priority than the mutex's
priority. If the mutex has prioirty higher or equal to the lowest interrupt priority,
acquiring the mutex also disables interrupts in the CPU.

When a mutex is released and another thread is waiting to acquire it, the ownership of the mutex
is transferred to the first waiter, and this waiter is made runnable. This is so that if the
previous owner has higher priority and tries to acquire it again, it will get blocked. Otherwise,
the highest priority thread will keep running, acquiring and releasing the mutex without giving
a chance to the low-priority waiting thread to ever get it.

The queue of waiters on a mutex is strictly FIFO, not priority based. This is to ensure
fairness for lower priority threads. Otherwise, lower priority threads may starve waiting
to get the mutex, as higher priority threads keep acquiring it first.

\subsection{Condition Variables}

\begin{schema}{Condvar}
    waitingThreads: ThreadQueue \\
    synchronizationScope: SYNCHRONIZATION\_SCOPE \\
%\where
\end{schema}

Besides the traditional condvar ``wait'' primitive, there is a ``wait with interrupts disabled''
primitive, intended to be used to synchronize a waiting thread with an ISR that is supposed to signal
the corresponding condvar on which the thread is waiting. The waiting thread must have interrupts
disabled in the processor, when it calls the ``wait with interrupts disabled'' primitve.

If more than one thread is waiting on the condvar, the ``signal'' primitive will wake up the
first thread in the condvar's queue. The ``broadcast'' primitive wakes up all the waiting threads.

There is a variation of the ``wait'' primitive that includes a timeout.

HiRTOS will not provide semaphore primitives as part of its APIs, as semaphores can be
easily implemented using condition variables and mutexes, for semaphores used only by threads.
For semaphores signaled from ISRs, they can be implemented with a combination of condition
variables and disabling interrupts, since mutexes cannot be used in ISRs. In this case, the thread
waiting on the condition variable to be signaled by an ISR, disables interrupts before checking
the condition and calls the ``wait for interrupt'' primitive, if the condition has not been met.
Otherwise, missed ``wake-ups'' could happen due to a race condition between the thread and the ISR.

%\subsection{Semaphores}

%\begin{schema}{Semaphore}
%    counter: \nat \\
%	counterNonZeroCondVar: Condvar \\
%\where
%    counterNonZeroCondVar.synchronizationScope = kLocalCpuInterruptAndThread
%\end{schema}

\subsection{Message Channels}

\begin{schema}{MessageChannel}
    GenericCircularBuffer[WORD\_LOCATION] \\
\end{schema}

\clearpage
\subsection{Generic Data Structures}

\subsubsection{Generic Linked Lists}

\begin{schema}{GenericLinkedList}[ElementType]
    listAnchor: LIST\_NODE \\
    numNodes: \nat \\
    zNodes: \finset LIST\_NODE \\
    zElements: \iseq ElementType \\
    zNodeToElem: LIST\_NODE \finj ElementType \\
    zNextNode: LIST\_NODE \finj LIST\_NODE \\
    zPrevNode: LIST\_NODE \finj LIST\_NODE \\
	zNodeToListAnchor: LIST\_NODE \finj LIST\_NODE \\
\where
    listAnchor \notin zNodes
\also
	numNodes = \# zNodes
\also
    \dom zNodeToElem = zNodes
\also
    \ran zNodeToElem = \ran zElements
\also
    \dom zNextNode = zNodes \cup \{listAnchor\}
\also
    \ran zNextNode = zNodes \cup \{listAnchor\}
\also
    \dom zPrevNode = \dom zNextNode
\also
    \ran zPrevNode = \ran zNextNode
\also
    \# zElements = \# zNodes
\also
    head~zElements = zNodeToElem(zNextNode(listAnchor)) \iff zElements \neq \emptyset
\also
    last~zElements = zNodeToElem(zPrevNode(listAnchor)) \iff zElements \neq \emptyset
\also
    head~zElements = last~zElements \iff \# zElements = 1
\also
    \forall x: zNodes @ \\
\t1      zPrevNode(zNextNode(x)) = x \land zNextNode(zPrevNode(x)) = x \land \\
%\t1      (zNodeToElem(x)).listNode = x \land \\ XXX
\t1      zNodeToListAnchor(x) = listAnchor
\also
    \forall x: zNodes @ \\
\t1      zNextNode^{\# zNodes + 1}(x) = x \land zPrevNode^{\# zNodes + 1}(x) = x
\also
    \forall x: zNodes; k: 1 \upto \# zNodes @ \\
\t1     zNextNode^{k}(x) \neq x \land zPrevNode^{k}(x) \neq x
\also
	 zNextNode(listAnchor) = zNodeToElem\inv(zElements(0))
\also
	 zPrevNode(listAnchor) = zNodeToElem\inv(last(zElements))
\also
     zNextNode(listAnchor) = listAnchor \iff zNodes = \emptyset
\also
    zPrevNode(listAnchor) = listAnchor \iff zNextNode(listAnchor) = listAnchor
\also
    zNextNode(listAnchor) = zPrevNode(listAnchor) \iff \# zNodes \leq 1
\end{schema}

\subsubsection{Generic Circular Buffers}

\begin{schema}{GenericCircularBuffer}[EntryType]
    zEntries: \iseq EntryType \\
    numEntries: \nat_1 \\
    entriesFilled: \nat \\
    readCursor: \nat \\
    writeCursor: \nat \\
    synchronizationScope: SYNCHRONIZATION\_SCOPE \\
    mutex: Mutex \\
    notEmptyCondvar: Condvar \\
    notFullCondvar: Condvar \\
\where
   \# zEntries = numEntries
\also
    entriesFilled \in 0 \upto numEntries
\also
   readCursor \in 0 \upto numEntries - 1
\also
   writeCursor \in 0 \upto numEntries - 1
\also
   writeCursor = readCursor \iff \\
\t1 (entriesFilled = 0 \lor entriesFilled = numEntries)
\also
    notEmptyCondvar \neq notFullCondvar
\also
    notEmptyCondvar.synchronizationScope = synchronizationScope
\also
    notFullCondvar.synchronizationScope = synchronizationScope
\end{schema}

If $synchronizationScope$ is $kLocalCpuInterruptAndThread$, the circular buffer operations
disable interrupts instead of using the circular buffer's mutex. If a circular buffer is empty,
a reader will block until the buffer is not empty.
Three behaviors are possible for writers when a circular buffer is full: block until there is
room to complete the write, drop the item to be written, overwrite the oldest entry with the
new item.

\clearpage
\begin{thebibliography}{9}

\bibitem{libcThreads}
ISO, ``N2731: Working draft of the C23 standard, section 7.26'', October 2021 \\
\url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2596.pdf#page=345&zoom=100,102,113}

\bibitem{prioCeiling}
Lui Sha et al, ``Priority Inheritance Protocols: An Approach to Real-Time Synchronization'', IEEE Transactions on Computers, September 1990 \\
\url{https://www.csie.ntu.edu.tw/~r95093/papers/Priority%20Inheritance%20Protocols%20An%20Approach%20to%20Real-Time%20Synchronization.pdf}

\bibitem{Zrm}
Mike Spivey, ``The Z Reference Manual'', second edition, Prentice-Hall, 1992 \\
\url{http://spivey.oriel.ox.ac.uk/~mike/zrm/zrm.pdf}

\bibitem{WayofZ}
Jonathan Jacky, ``The Way of Z'', Cambridge Press, 1997 \\
\url{http://staff.washington.edu/jon/z-book/index.html}

\bibitem{Fuzz}
Mike Spivey, ``The Fuzz checker'' \\
\url{http://spivey.oriel.ox.ac.uk/mike/fuzz}

\bibitem{DbC}
Bertrand Meyer, ``Touch of Class: Learning to Program Well with Objects and Contracts'', Springer, 2009 \\
\url{http://www.amazon.com/dp/3540921443}

\end{thebibliography}

\end{document}
