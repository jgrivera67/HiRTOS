\documentclass[11pt,letterpaper,twoside,openany]{book}
%\usepackage{lineno}
%\usepackage{afterpage}
\usepackage[pdftex]{graphicx}
\usepackage[pdftex, pdfborder={0 0 0}]{hyperref}
\usepackage[pdftex]{lscape}
\usepackage{listings}
%\usepackage{longtable}
%\usepackage{fancyvrb}
\usepackage{zed-csp}
\usepackage{tikz-uml}

\lstset{language=Ada,
        basicstyle=\small}

\addtolength{\textheight}{0.6in}
%\addtolength{\textheight}{1.25in}

\addtolength{\textwidth}{0.6in}
%\addtolength{\textwidth}{0.5in}

%\setlength{\parskip}{5pt plus1pt minus1pt}
%\addtocounter{secnumdepth}{1}

\pagestyle{plain}
%\linenumbers

\begin{document}
\title{Design of the \emph{HiRTOS} Multi-core \\
       Real-Time Operating System}
\author{Germ\'an Rivera \\
        \texttt jgrivera67@gmail.com}
\date{\today}
\maketitle

\frontmatter
\tableofcontents
%\listoffigures

\mainmatter
\raggedbottom
\pagestyle{myheadings}
\markboth{Design of the HiRTOS Multi-core Real-Time Operating System}{Design of the HiRTOS Real-Time Operating System}

\chapter{Introduction}

This document describes the design of \emph{HiRTOS} (\emph{``High Integrity''} RTOS),
a real-time operating system kernel that supports multi-core systems and that is
specifically designed for high integrity applications. The design is presented using
the \href{http://en.wikipedia.org/wiki/Z_notation}{Z notation} \cite{Zrm, WayofZ}.

Z is a software modeling notation based on discrete mathematics structures (such as sets,
relations and functions) and predicate logic. With Z, data structures can be specified in
terms of mathematical structures and their state invariants can be specified using mathematical
predicates. The pre-conditions and post-conditions of the operations that manipulate
the data structures can also be specified using predicates. Using Z for this purpose encourages
a rigorous and methodical thought process to elicit correctness properties, in a systematic way.
The \emph{HiRTOS} Z model described here was checked with the \verb'fuzz' tool~\cite{Fuzz}, a
Z type-checker, that catches Z type mismatches in predicates.

The code of \emph{HiRTOS} is written in SPARK Ada \cite{SparkAda}, a high integrity
subset of the Ada programming language. SPARK Ada code can be formally
verified at compile-time with the \verb`gnatprove` tool \cite{gnatprove}.

\section{Z Naming Conventions}
%\paragraph*{NOTE:}

The following naming conventions are used in the Z model of \emph{HiRTOS}:
\begin{itemize}
\item Z Primitive types are in uppercase.
\item Z Composite types (schema types) start with uppercase.
\item Z constants and variables start with lower case.
\item Identifiers that start with the $z$ prefix are meant to be modeling-only
      entities that do not physically correspond to code-level entities.
\end{itemize}

\section{HiRTOS Overview}

\subsection{Major Design Decisions}

\begin{itemize}
\item ISRs are seen as hardware-scheduled threads that have higher priority than all
software-scheduled threads. They can only be preempted by higher-priority ISRs.
They cannot block waiting on mutexes or condition variables.

\item For API simplicity, inspired by the thread synchronization primitives of the C11 standard
library \cite{libcThreads}, mutexes and condition variables are the only synchronization
primitives in \emph{HiRTOS}.
Other synchronization primitives such as semaphores, event flags and message queues can be
implemented on top of them.

\item Unlike standard mutexes, \emph{HiRTOS} mutexes have priorities to support the priority ceiling
protocol \cite{prioCeiling}.

\item \emph{HiRTOS} atomic levels can be used to disable the thread scheduler or to disable interrupts
at and below a given priority or to disable all interrupts.

\item In a multi-core platform, there is one \emph{HiRTOS} instance per CPU Core. Each \emph{HiRTOS} instance is
independent of each other. No resources are shared between \emph{HiRTOS} instances. No communication between
CPU cores is supported by \emph{HiRTOS}, so that the \emph{HiRTOS} API can stay the same for both single-core
and multi-core platforms. Inter-core communication would need to be provided outside of \emph{HiRTOS},
using doorbell interrupts and mailboxes or shared memory, for example.

\item
Threads are bound to the CPU core in which they were created, for the lifetime of the thread. That is,
no thread migration between CPU cores is supported.

\item
All RTOS objects such as threads, mutexes and condition variables are allocated internally
by \emph{HiRTOS} from statically allocated internal object pools.
These object pools are just RTOS-private global arrays of the corresponding RTOS object types,
sized at compile time via configuration parameters, whose values are application-specific.
RTOS object handles provided to application code are just indices into these internal object arrays.
No actual RTOS object pointers exposed to application code.
No dynamic allocation/deallocation of RTOS objects is supported and no static allocation of RTOS
objects in memory owned by application code is supported either.

\item
All application threads run in unprivileged mode. For each thread, the only writable memory,
by default, is its own stack and global variables. Stacks of other threads are not accessible.
MMIO space is only accessible to privileged code, by default. Application driver code, other
than ISRs, must request access (read-only or read-write permission) to \emph{HiRTOS} via a
system call.
\end{itemize}

\subsection{HiRTOS Code Architecture}

\begin{tikzpicture}
   \umlemptypackage[x=0, y=0]{Bare Metal C/C++ Applications}

   \begin{umlpackage}[x=0, y=-4]{C Interface Skins Library}
      \umlemptypackage[x=-3]{CMSIS RTOS2 Skin}
      \umlemptypackage[x=3]{FreeRTOS Skin}
      \umlemptypackage[x=6, y=-3]{C Interface Skin}
   \end{umlpackage}

   \begin{umlpackage}[x=0, y=-2]{HiRTOS Library Crate}
      \umlemptypackage[x=0, y=-10]{HiRTOS}
      \umlemptypackage[x=-4, y=-12]{HiRTOS Porting Layer}
   \end{umlpackage}

   \umlemptypackage[x=2, y=-18]{Portable Minimal Ada RTS Library Crate}

   \umlimport[geometry=|-]{CMSIS RTOS2 Skin}{C Interface Skin}
   \umlimport[geometry=|-]{FreeRTOS Skin}{C Interface Skin}
   \umlimport[geometry=|-]{C Interface Skin}{HiRTOS}
   \umlimport[geometry=|-]{HiRTOS}{HiRTOS Porting Layer}
   \umlimport[]{HiRTOS}{Portable Minimal Ada RTS Library Crate}
   \umlimport[geometry=|-]{HiRTOS Porting Layer}{Portable Minimal Ada RTS Library Crate}
   \umlimport[]{Bare Metal C/C++ Applications}{CMSIS RTOS2 Skin}
   \umlimport[]{Bare Metal C/C++ Applications}{FreeRTOS Skin}
   \umlimport[geometry=-|]{Bare Metal C/C++ Applications}{C Interface Skin}
\end{tikzpicture}

\begin{tikzpicture}
   \umlemptypackage[x=0, y=0]{Bare Metal Ada Applications}

   \umlemptypackage[x=0, y=-4]{Ada RTS Tasking Skin Library Crate}

   \begin{umlpackage}[x=0, y=-8]{HiRTOS Library Crate}
      \umlemptypackage[x=0, y=0]{HiRTOS}
      \umlemptypackage[x=-4, y=-3]{HiRTOS Porting Layer}
   \end{umlpackage}

   \umlemptypackage[x=4, y=-16]{Portable Minimal Ada RTS Library Crate}

   \umlimport[]{Ada RTS Tasking Skin Library Crate}{HiRTOS}
   \umlimport[geometry=|-]{HiRTOS}{HiRTOS Porting Layer}
   \umlimport[]{HiRTOS}{Portable Minimal Ada RTS Library Crate}
   \umlimport[geometry=|-]{HiRTOS Porting Layer}{Portable Minimal Ada RTS Library Crate}
   \umlimport[]{Bare Metal Ada Applications}{Ada RTS Tasking Skin Library Crate}
   \umlimport[geometry=-|]{Bare Metal Ada Applications}{Portable Minimal Ada RTS Library Crate}
\end{tikzpicture}

\begin{tikzpicture}
   \begin{umlpackage}{HiRTOS}
      \umlbasiccomponent[name=RTOSprivate]{RTOS\_Private}
      \umlbasiccomponent[name=GenericLinkedList, x=-3, y=-3]{Generic\_Linked\_List}
   \end{umlpackage}

   \umlimport[geometry=|-]{RTOSprivate}{GenericLinkedList}
\end{tikzpicture}

\chapter{\emph{HiRTOS} Z Specification}

\section{\emph{HiRTOS} Configuration Parameters}

Constants defined here represent compile-time configuration parameters for
\emph{HiRTOS}.

\begin{axdef}
    maxNumThreads: \nat_1 \\
    maxNumMutexes: \nat_1 \\
    maxNumCondvars: \nat_1 \\
    maxNumTimers: \nat_1 \\
    numThreadPriorities: \nat_1 \\
\where
    maxNumThreads > 2
\end{axdef}

The minimum number of threads that can be configured is 2, which corresponds to the \emph{HiRTOS} pre-defined threads:
the idle thread and the tick timer thread.

\section{\emph{HiRTOS} Target Platform Parameters}

Constants defined here represent compile-time target platform parameters for
\emph{HiRTOS}.

\begin{axdef}
    maxNumCpus: \nat_1 \\
    minMemoryAddress: \nat \\
    maxMemoryAddress: \nat_1 \\
    numInterruptPriorities: \nat_1 \\
    numTimerWheelSpokes: \nat_1 \\
\where
    minMemoryAddress < maxMemoryAddress
\end{axdef}

\clearpage
\section{\emph{HiRTOS} Primitive Types}

\begin{zed}
    CpuIdType == 0 \upto maxNumCpus \\
    invalidCpuId == maxNumCpus \\
    ValidCpuIdType == CpuIdType \setminus \{ invalidCpudId \} \\
    MemoryAddressType == minMemoryAddress \upto maxMemoryAddress \\
    nullAddress == 0 \\
    ThreadIdType == 0 \upto maxNumThreads \\
    invalidThreadId == maxNumThreads \\
    ValidThreadIdType == ThreadIdType \setminus \{ invalidThreadId \} \\
    ThreadPriorityType == 0 \upto numThreadPriorities \\
    invalidThreadPriority == numThreadPriorities \\
    ValidThreadPriorityType == ThreadPriorityType \setminus \{ invalidThreadPriority \} \\
    MutexIdType == 0 \upto maxNumMutexes \\
    invalidMutexId == maxNumMutexes \\
    ValidMutexIdType == MutexIdType \setminus \{ invalidMutexId \} \\
    CondvarIdType == 0 \upto maxNumCondvars \\
    invalidCondvarId == maxNumCondvars \\
    ValidCondvarIdType == CondvarIdType \setminus \{ invalidCondvarId \} \\
    TimerIdType == 0 \upto maxNumTimers \\
    invalidTimerId == maxNumTimers \\
    ValidTimerIdType == TimerIdType \setminus \{ invalidTimerId \} \\
    InterruptPrioirtyType == 0 \upto numInterruptPriorities \\
    invalidInterruptPriority == numInterruptPriorities \\
    ValidInterruptPriorityType == InterruptPriorityType \setminus \{ invalidInterruptPriority \} \\
    AtomicLevelType == 0 \upto numInterruptPriorities + 1 \\
    atomicLevelNoInterrupts == min~AtomicLevelType \\
    atomicLevelSingleThread == max~AtomicLevelType - 1 \\
    atomicLevelNone == max~AtomicLevelType \\
    InterruptNestingCounterType == 0 \upto numInterruptPriorities \\
    ActiveInterruptNestingCounterType == InterruptNestingCounterType \setminus \{~ 0 ~\} \\
    CpuInterruptMaskingStateType ::= cpuInterruptsEnabled | cpuInterruptsDisabled \\
    CpuPrivilegeType ::= cpuPrivileged | cpuUnprivileged \\
    MemoryProtectionStateType ::= memoryProtectionOn | memoryProtectionOff \\
    CpuExecutionModeType ::= cpuExecutingResetHandler | cpuExecutingInterruptHandler | \\
\t7                          cpuExecutingThread \\
    ThreadStateType ::= threadNotCreated | threadRunnable | threadRunning | \\
\t5                     threadInterrupted | threadBlocked \\
    HiRtosStateType ::= threadSchedulerStopped | threadSchedulerRunning \\
    TimerTicksType == \nat \\
    ThreadQueueType == \iseq ValidThreadIdType \\
    MutexListType == \iseq ValidMutexIdType \\
    TimerListType == \iseq ValidTimerIdType \\
    TimerWheelSpokeIndexType == 0 \upto numTimerWheelSpokes \\
    invalidTimerWheelSpokeIndex == max~TimerWheelSpokeIndexType \\
    ValidTimerWheelSpokeIndexType == TimerWheelSpokeIndexType \setminus \{~ invalidTimerWheelSpokeIndex ~\} \\
    PerCpuThreadSetType == \finset_1 ValidThreadIdType \\
    PerCpuMutexSetType == \finset ValidMutexIdType \\
    PerCpuCondvarSetType == \finset_1 ValidCondvarIdType \\
    PerCpuTimerSetType == \finset_1 ValidTimerIdType \\
\end{zed}

For interrupts, lower priority values represent higher priorities. For threads, lower priority
values represent lower priorities.

\section{\emph{HiRTOS} Axiomatic Definitions}

\begin{axdef}
    zThreadInstances: ValidThreadIdType \inj ThreadType \\
    zMutexInstances: ValidMutexIdType \inj MutexType \\
    zCondvarInstances: ValidCondvarIdType \inj CondvarType \\
    zTimerInstances: ValidTimerIdType \inj TimerType \\
    zRtosCpuInstances: ValidCpuIdType \inj HiRtosCpuInstanceType \\
    zCpuToISRstackAddressRange: ValidCpuIdType \inj \finset_1 MemoryAddressType \\
\where
    \forall i : \dom rtosCpuInstances @ rtosCpuInstances(i).cpuId = i
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    zCpuToISRstackAddressRange(i) ~\} = \emptyset
\end{axdef}

\begin{axdef}
    zGetHighestPriorityThread: ValidCpuIdType \inj ThreadIdType \\
\where
    \forall cpuId : ValidCpuIdType @ \\
\t1     (\LET threadId == zGetHighestPriorityThread(cpuId) @ \\
\t2         threadId \in zRtosCpuInstances(cpuId).allThreads \land \\
\t2        (\forall i: zRtosCpuInstances(cpuId).allThreads \setminus \{~ threadId ~\} @ \\
\t3             zThreadInstances (i).priority < zThreadInstances(threadId).priority))
\end{axdef}

\begin{axdef}
   interruptPriorities: InterruptIdType \fun InterruptPrioirtyType
\end{axdef}
\clearpage
\section{\emph{HiRTOS} State Variables}

\begin{schema}{HiRtosType}
    createdThreadInstances: ValidThreadIdType \finj ThreadType \\
    createdMutexInstances: ValidMutexIdType \finj MutexType \\
    createdCondvarInstances: ValidCondvarIdType \finj CondvarType \\
    createdTimerInstances: ValidTimerIdType \finj TimerType \\
    rtosCpuInstances: ValidCpuIdType \finj HiRtosCpuInstanceType \\
\where
    createdThreadInstances \subseteq zThreadInstances
\also
    createdMutexInstances \subseteq zMutexdInstances
\also
    createdCondvarInstances \subseteq zCondvarInstances
\also
    createdTimerInstances \subseteq zTimerInstances
\also
    rtosCpuInstances = zRtosCpuInstances
\also
    \bigcup~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allThreads ~\} = createdThreadInstances
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allThreads ~\} = \emptyset
\also
    \bigcup~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allMutexes ~\} = createdMutexInstances
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allMutexes ~\} = \emptyset
\also
    \bigcup~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allCondvars ~\} = createdCondvarInstances
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allCondvars ~\} = \emptyset
\also
    \bigcup~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allTimers ~\} = createdTimerInstances
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allTimers ~\} = \emptyset
\end{schema}

\clearpage
The state variables and internal data structures of each per-CPU \emph{HiRTOS} instance
are described below:

\begin{schema}{HiRtosCpuInstanceType}
    cpuId: CpuIdType \\
    threadSchedulerState: ThreadSchedulerStateType \\
    currentAtomicLevel: AtomicLevelType \\
    currentCpuExecutionMode: CpuExecutionModeType \\
    currentThreadId: ThreadIdType \\
    timerTicksSinceBoot: TimerTicksType \\
    idleThreadId: ValidThreadIdType \\
    tickTimerThreadId: ValidThreadIdType \\
    interruptNestingLevelStack: InterruptNestingLevelStackType \\
    allThreads: PerCpuThreadSetType \\
    allMutexes: PerCpuMutexSetType \\
    allCondvars: PerCpuCondvarSetType \\
    allTimers: PerCpuTimerSetType \\
    runnableThreadQueues: ValidThreadPriorityIdType \inj ThreadQueueType \\
    timerWheel: TimerWheelType \\
    zCpuInterruptMaskingState: CpuInterruptMaskingStateType \\
    zCpuPrivilege: CpuPrivilegeType \\
    zMemoryProtectionState: MemoryProtectionStateType \\
\where
    \{~ idleThreadId, tickTimerThreadId ~\} \subseteq allThreads
\also
    tickTimerThreadId \neq idleThreadId
\also
    threadSchedulerState = threadSchedulerRunning \implies \\
\t1    currentThreadId = zGetHighestPriorityThread(cpuId)
\also
    zCpuInterruptMaskingState = cpuInterruptsEnabled \iff \\
\t1    currentAtomicLevel > AtomicLevelNoInterrupts
\also
    zCpuInterruptMaskingState = cpuInterruptsDisabled \implies \\
\t1    zCpuPrivilege = cpuPrivileged
\also
    currentAtomicLevel < AtomicLevelNone \implies zCpuPrivilege = cpuPrivileged
\also
    \bigcap~\{~ i: allThreads @ \{~ zThreadInstances(i).builtinCondvarId ~\} ~\} = \emptyset
\also
    \bigcap~\{~ i: allThreads @ \{~ zThreadInstances(i).delayTimerId ~\} ~\} = \emptyset
\also
    \forall p: ValidThreadPrioirtyType @ \\
\t1    \forall t: \ran runnableThreadQueues(p) @ t.priority = p
\end{schema}

\begin{schema}{InterruptNestingLevelStackType}
    interruptNestingLevels: ActiveInterruptNestingCounterType \inj InterruptNestingLevelType \\
    currentInterruptNestingCounter: InterruptNestingCounterType \\
    zCpuId: ValidCpuIdType
\where
   \forall x: ActiveInterruptNestingCounterType @ \\
\t1   interruptNestingLevels(x).interruptNestingCounter = x \land \\
\t1   interruptNestingLevels(x).savedStackPoint \in zCpuToISRstackAddressRange(zCpuId)
\also
   \dom interruptNestingLevels = 1 .. currentInterruptNestingCounter
\end{schema}

\begin{schema}{InterruptNestingLevelType}
   interruptId : InterruptIdType \\
   interruptNestingCounter: ActiveInterruptNestingCounterType \\
   savedStackPointer: CpuRegisterValueType \\
   atomicLevel: AtomicLevelType \\
\where
   atomicLevel \leq interruptPriorities (interruptId)
\also

\end{schema}

\begin{schema}{TimerWheelType}
   wheelSpokesHashTable: ValidTimerWheelSpokeIndexType \fun \finset TimerIdType \\
   currentWheelSpokeIndex: ValidTimerWheelSpokeIndexType
\where
    \bigcap~\{~ i: ValidTimerWheelSpokeIndexType @ wheelSpokes(i) ~\} = \emptyset
\end{schema}

\begin{schema}{TimerType}
\where
\end{schema}

\begin{schema}{ThreadType}
\where
\end{schema}

\begin{schema}{CondvarType}
\where
\end{schema}

\begin{schema}{MutexType}
\where
\end{schema}

\clearpage
\section{\emph{HiRTOS} Initialization}

On boot, before the \verb`HiRTOS.Initialize` \emph{HiRTOS} API is called on any CPU core,
the global state of \emph{HiRTOS} is as follows:

\begin{schema}{HiRtosInitialState}
    HiRtosType'
\where
    createdThreadInstances' =  \emptyset
\also
    createdMutexInstances' = \emptyset
\also
    createdCondvarInstances' = \emptyset
\also
    createdTimerInstances' = \emptyset
\end{schema}

When \verb`HiRTOS.Initialize` is called for a given CPU core, the idle thread
and the tick timer thread for that CPU are created. The initial state of the
\emph{HiRTOS} instance for that CPU is as follows:

\begin{schema}{HiRtosCpuInstanceInitialState}
    HiRtosCpuInstanceType'
\where
    threadSchedulerState' = threadSchedulerStopped
\also
    currentThreadId' = invalidThreadId
\also
    currentAtomicLevel' = AtomicLevelNone
\also
    currentCpuExecutionMode' = cpuExecutingResetHandler
\also
    idleThreadId' \neq invalidThreadId
\also
    tickTimerThreadId' \neq invalidThreadId
\also
    tickTimerThreadId' \neq idleThreadId'
\also
    allThreads' = \{~ idleThreadId', tickTimerThreadId' ~\}
\also
    allCondvars' = \{~ zThreadInstances(idleThreadId').builtinCondvarId, \\
\t3                    zThreadInstances(tickTimerThreadId').builtinCondvarId ~\}
\also
    allTimers' = \{~ zThreadInstances(idleThreadId').delayTimerId, \\
\t3                  zThreadInstances(tickTimerThreadId').delayTimerId ~\}
\also
    timerTicksSinceBoot' = 0
\also
    interruptNestingLevelStack' = \theta~InterruptNestingLevelStackInitialState
\also
   interruptNestingLevelStack'.zCpuId = cpuId
\also
    timerWheel' = \theta~TimerWheelInitialState
\also
    zCpuInterruptMaskingState' = cpuInterruptsEnabled
\also
    zCpuPrivilege' = cpuUnprivileged
\also
    zMemoryProtectionState' = memoryProtectionOn
\also
    runnableThreadQueues'(min~ ValidInterruptPriorityIdType) = \langle idleThreadId \rangle
\also
    runnableThreadQueues'(max~ ValidInterruptPriorityIdType) = \langle tickTimerThreadId \rangle
\also
     \forall p: ValidThreadPrioirtyType \setminus \\
\t2         \{ min~ValidThreadPrioirtyType, \max~ValidThreadPrioirtyType \} @ \\
\t1      runnableThreadQueues'(p) = \emptyset
\end{schema}

\begin{schema}{InterruptNestingLevelStackInitialState}
   InterruptNestingLevelStackType'
\where
   currentInterruptNestingCounter = 1 \\
\end{schema}

\begin{schema}{InterruptNestingLevelInitialState}
   InterruptNestingLevelType'
\where
   interruptId' = invalidInterruptId
\also
   interruptNestingCounter' = 0
\also
   savedStackPointer' = nullAddress
\also
   atomicLevel' = atomicLevelNones
\end{schema}

\begin{schema}{TimerWheelInitialState}
   TimerWheelType'
\where
   \ran wheelSpokesHashTable = \{~ \emptyset ~\}
\also
   currentWheelSpokeIndex = min~ValidTimerWheelSpokeIndexType
\end{schema}

\begin{schema}{TimerTypeInitialState}
   \where
\end{schema}

\begin{schema}{ThreadTypeInitialState}
\where
\end{schema}

\begin{schema}{CondvarTypeInitialState}
\where
\end{schema}

\begin{schema}{MutexTypeInitialState}
\where
\end{schema}

\clearpage
\section{Starting the Per-CPU \emph{HiRTOS} Thread Scheduler}

When calling the \verb`HiRTOS.Start_Thread_Scheduler` \emph{HiRTOS} API, on a given
CPU core, RTOS multi-tasking is started on the given CPU, as described by the
precondition/postcondition contract shown below:

\begin{schema}{HiRtosStartThreadScheduler}
    \Delta HiRtosCpuInstanceType \\
\where
    threadSchedulerState = threadSchedulerStopped
\also
    currentThreadId = invalidThreadId
\also
    currentAtomicLevel = AtomicLevelNone
\also
   zCpuPrivilege = cpuPrivileged
\also
    currentCpuExecutionMode = cpuExecutingResetHandler
\also
\also
    threadSchedulerState' = threadSchedulerRunning
\also
    currentThreadId' = zGetHighestPriorityThread(cpuId)
\also
    currentAtomicLevel' = AtomicLevelNone
\also
   zCpuPrivilege = cpuUnprivileged
\also
    currentCpuExecutionMode' = cpuExecutingThread
\end{schema}

\section{Entering \emph{HiRTOS} from Interrupt Context}

After calling the \verb$HiRTOS.Enter_Interrupt_Context$ \emph{HiRTOS} API, from an ISR on a given CPU core, RTOS multi-tasking
the \emph{HiRTOS} environment for interrupt context is entered.

\begin{schema}{HiRtosEnterInterruptContext}
    \Delta HiRtosInstanceType \\
    zInterruptId?: InterruptIdType
\where
\end{schema}

\section{Exiting \emph{HiRTOS} from Interrupt Context}

After calling the \verb$HiRTOS.Exit_Interrupt_Context$ \emph{HiRTOS} API, from an ISR on a given CPU core, RTOS multi-tasking
the \emph{HiRTOS} environment for interrupt context is exited.

\begin{schema}{HiRtosExitInterruptContext}
    \Delta HiRtosInstanceType \\
    zCpuId?: CpuIdType \\
    zInterruptId?: InterruptIdType
\where
\end{schema}

\clearpage
\begin{thebibliography}{9}

\bibitem{libcThreads}
ISO, ``N2731: Working draft of the C23 standard, section 7.26'', October 2021 \\
\url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2596.pdf#page=345&zoom=100,102,113}

\bibitem{prioCeiling}
Lui Sha et al, ``Priority Inheritance Protocols: An Approach to Real-Time Synchronization'', IEEE Transactions on Computers, September 1990 \\
\url{https://www.csie.ntu.edu.tw/~r95093/papers/Priority%20Inheritance%20Protocols%20An%20Approach%20to%20Real-Time%20Synchronization.pdf}

\bibitem{Zrm}
Mike Spivey, ``The Z Reference Manual'', second edition, Prentice-Hall, 1992 \\
\url{http://spivey.oriel.ox.ac.uk/~mike/zrm/zrm.pdf}

\bibitem{WayofZ}
Jonathan Jacky, ``The Way of Z'', Cambridge Press, 1997 \\
\url{http://staff.washington.edu/jon/z-book/index.html}

\bibitem{Fuzz}
Mike Spivey, ``The Fuzz checker'' \\
\url{http://spivey.oriel.ox.ac.uk/mike/fuzz}

\bibitem{DbC}
Bertrand Meyer, ``Touch of Class: Learning to Program Well with Objects and Contracts'', Springer, 2009 \\
\url{http://www.amazon.com/dp/3540921443}

\bibitem{SparkAda}
John W. McCormick, Peter C. Chapin,``Building High Integrity Applications with SPARK'', Cambridge University Press, 2015 \\
\url{https://www.amazon.com/Building-High-Integrity-Applications-SPARK/dp/1107040736}

\bibitem{gnatprove}
AdaCore,``Formal Verification with GNATprove'' \\
\url{https://docs.adacore.com/spark2014-docs/html/ug/en/gnatprove.html}

\end{thebibliography}

\end{document}
