\documentclass[11pt,letterpaper,twoside,openany]{book}
%\usepackage{lineno}
%\usepackage{afterpage}
\usepackage[pdftex]{graphicx}
\usepackage[pdftex, pdfborder={0 0 0}]{hyperref}
\usepackage[pdftex]{lscape}
\usepackage{listings}
%\usepackage{longtable}
%\usepackage{fancyvrb}
\usepackage{zed-csp}

\lstset{language=Ada,
        basicstyle=\small}

\addtolength{\textheight}{0.6in}
%\addtolength{\textheight}{1.25in}

\addtolength{\textwidth}{0.6in}
%\addtolength{\textwidth}{0.5in}

%\setlength{\parskip}{5pt plus1pt minus1pt}
%\addtocounter{secnumdepth}{1}

\pagestyle{plain}
%\linenumbers

\begin{document}
\title{Design of the \emph{HiRTOS} Multi-core \\
       Real-Time Operating System}
\author{Germ\'an Rivera \\
        \texttt jgrivera67@gmail.com}
\date{\today}
\maketitle

\frontmatter
\tableofcontents
%\listoffigures

\mainmatter
\raggedbottom
\pagestyle{myheadings}
\markboth{Design of the HiRTOS Multi-core Real-Time Operating System}{Design of the HiRTOS Real-Time Operating System}

\chapter{Introduction}

This document describes the design of \emph{HiRTOS} (\emph{``High Integrity''} RTOS),
a real-time operating system kernel that supports multi-core systems and that is
specifically designed for high integrity applications. The design is presented using
the \href{http://en.wikipedia.org/wiki/Z_notation}{Z notation} \cite{Zrm, WayofZ}.

Z is a software modeling notation based on discrete mathematics structures (such as sets,
relations and functions) and predicate logic. With Z, data structures can be specified in
terms of mathematical structures and their state invariants can be specified using mathematical
predicates. The pre-conditions and post-conditions of the operations that manipulate
the data structures can also be specified using predicates. Using Z for this purpose encourages
a rigorous and methodical thought process to elicit correctness properties, in a systematic way.
The \emph{HiRTOS} Z model described here was checked with the \verb'fuzz' tool~\cite{Fuzz}, a
Z type-checker, that catches Z type mismatches in predicates.

The code of \emph{HiRTOS} is written in SPARK Ada \cite{SparkAda}, a high integrity
subset of the Ada programming language. SPARK Ada code can be formally
verified at compile-time with the \verb`gnatprove` tool \cite{gnatprove}.

\section{Z Naming Conventions}
%\paragraph*{NOTE:}

The following naming conventions are used in the Z model of \emph{HiRTOS}:
\begin{itemize}
\item Z Primitive types are in uppercase.
\item Z Composite types (schema types) start with uppercase.
\item Z constants and variables start with lower case.
\item Identifiers that start with the $z$ prefix are meant to be modeling-only
      entities that do not physically correspond to code-level entities.
\end{itemize}

\section{Major Design Decisions}

\begin{itemize}
\item ISRs are seen as hardware-scheduled threads that have higher priority than all
software-scheduled threads. They can only be preempted by higher-priority ISRs.
They cannot block waiting on mutexes or condition variables.

\item For API simplicity, inspired by the thread synchronization primitives of the C11 standard
library \cite{libcThreads}, mutexes and condition variables are the only real synchronization
primitives in \emph{HiRTOS}.
Other synchronization primitives such as semaphores, event flags and message queues can be
implemented on top of them.

\item Unlike stadanrd mutexes, \emph{HiRTOS} mutexes have priorities to support the priority ceiling
protocol \cite{prioCeiling}.

\item \emph{HiRTOS} atomic levels can be used to disable the thread scheduler or to disable interrupts
at and below a given priority or to disable all interrupts.

\item In a multi-core platform, there is one \emph{HiRTOS} instance per CPU Core. Each \emph{HiRTOS} instance is
independent of each other. No resources are shared between \emph{HiRTOS} instances. No communication between
CPU cores is supported by \emph{HiRTOS}, so that the \emph{HiRTOS} API can stay the same for both single-core
and multi-core platforms. Inter-core communication would need to be provided outside of \emph{HiRTOS},
using doorbell interrupts and mailboxes or shared memory, for example.

\item
Threads are bound to the CPU core in which they were created, for the lifetime of the thread. That is,
no thread migration between CPU cores is supported.

\item
All RTOS objects such as threads, mutexes and condition variables are allocated internally
by \emph{HiRTOS} from statically allocated internal object pools.
These object pools are just RTOS-private global arrays of the corresponding RTOS object types,
sized at compile time via configuration parameters, whose values are application-specific.
RTOS object handles provided to application code are just indices into these internal object arrays.
No actual RTOS object pointers exposed to application code.
No dynamic allocation/deallocation of RTOS objects is supported and no static allocation of RTOS
objects in memory owned by application code is supported either.

\item
All application threads run in unprivileged mode. For each thread, the only writable memory,
by default, is its own stack and global variables. Stacks of other threads are not accessible.
MMIO space is only accessible to privileged code, by default. Application driver code, other
than ISRs, must request access (read-only or read-write permission) to \emph{HiRTOS} via a
system call.
\end{itemize}

\chapter{\emph{HiRTOS} Z Specification}

\section{\emph{HiRTOS} Configuration Parameters}

Constants defined here represent compile-time configuration parameters for
\emph{HiRTOS}.

\begin{axdef}
    maxNumThreads: \nat_1 \\
    maxNumMutexes: \nat_1 \\
    maxNumCondvars: \nat_1 \\
    maxNumTimers: \nat_1 \\
    numThreadPriorities: \nat_1 \\
\where
    maxNumThreads > 2
\end{axdef}

The minimum number of threads that can be configured is 2, which corresponds to the \emph{HiRTOS} pre-defined threads:
the idle thread and the tick timer thread.

\section{\emph{HiRTOS} Target Platform Parameters}

Constants defined here represent compile-time target platform parameters for
\emph{HiRTOS}.

\begin{axdef}
    maxNumCpus: \nat_1 \\
    minMemoryAddress: \nat \\
    maxMemoryAddress: \nat_1 \\
    numInterruptPriorities: \nat_1 \\
\where
    minMemoryAddress < maxMemoryAddress
\end{axdef}

\clearpage
\section{\emph{HiRTOS} Primitive Types}

\begin{zed}
    CpuIdType == 0 \upto maxNumCpus \\
    invalidCpuId == maxNumCpus \\
    ValidCpuIdType == CpuIddType \setminus \{ InvalidCpudId \} \\
    MemoryAddressType == minMemoryAddress \upto maxMemoryAddress \\
    ThreadIdType == 0 \upto maxNumThreads \\
    invalidThreadId == maxNumThreads \\
    ValidThreadIdType == ThreadIdType \setminus \{ InvalidThreadId \} \\
    ThreadPrioirtyType == 0 \upto numThreadPriorities \\
    invalidThreadPriority == numThreadPriorities \\
    ValidThreadPriorityType == ThreadPriorityType \setminus \{ InvalidThreadPriority \} \\
    MutexIdType == 0 \upto maxNumMutexes \\
    invalidMutexId == maxNumMutexes \\
    ValidMutexIdType == MutexIdType \setminus \{ InvalidMutexId \} \\
    CondvarIdType == 0 \upto maxNumCondvars \\
    invalidCondvarId == maxNumCondvars \\
    ValidCondvarIdType == CondvarIdType \setminus \{ InvalidCondvarId \} \\
    TimerIdType == 0 \upto maxNumTimers \\
    invalidTimerId == maxNumTimers \\
    ValidTimerIdType == TimerIdType \setminus \{ InvalidTimerId \} \\
    InterruptPrioirtyType == 0 \upto numInterruptPriorities \\
    invalidInterruptPriority == numInterruptPriorities \\
    ValidInterruptPriorityIdType == InterruptPriorityType \setminus \{ InvalidInterruptPriorityId \} \\
    AtomicLevelType == 0 \upto numInterruptPriorities + 1 \\
    atomicLevelNoInterrupts == min~AtomicLevelType \\
    atomicLevelSingleThread == max~AtomicLevelType - 1 \\
    atomicLevelNone == max~AtomicLevelType \\
    CpuInterruptMaskingStateType ::= cpuInterruptsEnabled | cpuInterruptsDisabled \\
    CpuPrivilegeType ::= cpuPrivileged | cpuUnprivileged \\
    MemoryProtectionStateType ::= memoryProtectionOn | memoryProtectionOff \\
    CpuExecutionModeType ::= cpuExecutingResetHandler | cpuExecutingInterruptHandler | \\
\t7                          cpuExecutingThread \\
    ThreadStateType ::= threadNotCreated | threadRunnable | threadRunning | \\
\t5                     threadInterrupted | threadBlocked \\
    HiRtosStateType ::= threadSchedulerStopped | threadSchedulerRunning \\
    TimerTicksType == \nat \\
    ThreadQueueType == \iseq ValidThreadIdType \\
    MutexListType == \iseq ValidMutexIdType \\
    TimerListType == \iseq ValidTimerIdType \\
    PerCpuThreadSetType == \finset_1 ValidThreadIdType \\
    PerCpuMutexSetType == \finset ValidMutexIdType \\
    PerCpuCondvarSetType == \finset_1 ValidCondvarIdType \\
    PerCpuTimerSetType == \finset_1 ValidTimerIdType \\
\end{zed}

For interrupts, lower priority values represent higher priorities. For threads, lower priority
values represent lower priorities.

\section{\emph{HiRTOS} Axiomatic Definitions}

\begin{axdef}
    zThreadInstances: ValidThreadIdType \inj ThreadType \\
    zMutexInstances: ValidMutexIdType \inj MutexType \\
    zCondvarInstances: ValidCondvarIdType \inj CondvarType \\
    zTimerInstances: ValidTimerIdType \inj TimerType \\
    zRtosCpuInstances: ValidCpuIdType \inj HiRtosCpuInstanceType \\
\where
    \forall i : \dom rtosCpuInstances @ rtosCpuInstances(i).cpuId = i
\end{axdef}

\begin{axdef}
    zGetHighestPriorityThread: ValidCpuIdType \inj ThreadIdType \\
\where
    \forall cpuId : ValidCpuIdType @ \\
\t1     (\LET threadId == zGetHighestPriorityThread(cpuId) @ \\
\t2         threadId \in zRtosCpuInstances(cpuId).allThreads \land \\
\t2         \forall i: zRtosCpuInstances(cpuId).allThreads \setminus \{~ threadId ~\} @ \\
\t3             zThreadInstances (i).priority < zThreadInstances(threadId).priority)
\end{axdef}

\clearpage
\section{\emph{HiRTOS} State Variables}

\begin{schema}{HiRtosType}
    createdThreadInstances: ValidThreadIdType \finj ThreadType \\
    createdMutexInstances: ValidMutexIdType \finj MutexType \\
    createdCondvarInstances: ValidCondvarIdType \finj CondvarType \\
    createdTimerInstances: ValidTimerIdType \finj TimerType \\
    rtosCpuInstances: ValidCpuIdType \finj HiRtosCpuInstanceType \\
\where
    createdThreadInstances \subseteq zThreadInstances
\also
    createdMutexInstances \subseteq zMutexdInstances
\also
    createdCondvarInstances \subseteq zCondvarInstances
\also
    createdTimerInstances \subseteq zTimerInstances
\also
    rtosCpuInstances = zRtosCpuInstances
\also
    \bigcup~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allThreads ~\} = createdThreadInstances
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allThreads ~\} = \emptyset
\also
    \bigcup~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allMutexes ~\} = createdMutexInstances
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allMutexes ~\} = \emptyset
\also
    \bigcup~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allCondvars ~\} = createdCondvarInstances
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allCondvars ~\} = \emptyset
\also
    \bigcup~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allTimers ~\} = createdTimerInstances
\also
    \bigcap~\{~ i: ValidCpuIdType @ \\
\t1    rtosCpuInstances(i).allTimers ~\} = \emptyset
\end{schema}

\clearpage
The state variables and internal data structures of each per-CPU \emph{HiRTOS} instance
are described below:

\begin{schema}{HiRtosCpuInstanceType}
    cpuId: CpuIdType \\
    threadSchedulerState: ThreadSchedulerStateType \\
    currentAtomicLevel: AtomicLevelType \\
    currentCpuExecutionMode: CpuExecutionModeType \\
    currentThreadId: ThreadIdType \\
    timerTicksSinceBoot: TimerTicksType \\
    idleThreadId: ValidThreadIdType \\
    tickTimerThreadId: ValidThreadIdType \\
    interruptNestingLevelStack: InterruptNestingLevelStackType \\
    allThreads: PerCpuThreadSetType \\
    allMutexes: PerCpuMutexSetType \\
    allCondvars: PerCpuCondvarSetType \\
    allTimers: PerCpuTimerSetType \\
    runnableThreadQueues: ValidThreadPriorityIdType \inj ThreadQueueType \\
    timerWheel: TimerWheelType \\
    zCpuInterruptMaskingState: CpuInterruptMaskingStateType \\
    zCpuPrivilege: CpuPrivilegeType \\
    zMemoryProtectionState: MemoryProtectionStateType \\
\where
    \{~ idleThreadId, tickTimerThreadId ~\} \subseteq allThreads
\also
    tickTimerThreadId \neq idleThreadId
\also
    threadSchedulerState = threadSchedulerRunning \implies \\
\t1    currentThreadId = zGetHighestPriorityThread(cpuId)
\also
    zCpuInterruptMaskingState = cpuInterruptsEnabled \iff \\
\t1    currentAtomicLevel > AtomicLevelNoInterrupts
\also
    zCpuInterruptMaskingState = cpuInterruptsDisabled \implies \\
\t1    zCpuPrivilege = cpuPrivileged
\also
    currentAtomicLevel < AtomicLevelNone \implies zCpuPrivilege = cpuPrivileged
\also
    \bigcap~\{~ i: allThreads @ \{~ zThreadInstances(i).builtinCondvarId ~\} ~\} = \emptyset
\also
    \bigcap~\{~ i: allThreads @ \{~ zThreadInstances(i).delayTimerId ~\} ~\} = \emptyset
\also
    \forall p: ValidThreadPrioirtyType @ \\
\t1    \forall t: \ran runnableThreadQueues(p) @ t.priority = p
\end{schema}

\clearpage
\section{\emph{HiRTOS} Initialization}

On boot, before the \verb`HiRTOS.Initialize` \emph{HiRTOS} API is called on any CPU core,
the global state of \emph{HiRTOS} is as follows:

\begin{schema}{HiRtosInitialState}
    HiRtosType'
\where
    createdThreadInstances' =  \emptyset
\also
    createdMutexInstances' = \emptyset
\also
    createdCondvarInstances' = \emptyset
\also
    createdTimerInstances' = \emptyset
\end{schema}

When \verb`HiRTOS.Initialize` is called for a given CPU core, the idle thread
and the tick timer thread for that CPU are created. The initial state of the
\emph{HiRTOS} instance for that CPU is as follows:

\begin{schema}{HiRtosCpuInstanceInitialState}
    HiRtosCpuInstanceType'
\where
    threadSchedulerState' = threadSchedulerStopped
\also
    currentThreadId' = invalidThreadId
\also
    currentAtomicLevel' = AtomicLevelNone
\also
    currentCpuExecutionMode' = cpuExecutingResetHandler
\also
    idleThreadId' \neq invalidThreadId
\also
    tickTimerThreadId' \neq invalidThreadId
\also
    tickTimerThreadId' \neq idleThreadId'
\also
    allThreads' = \{~ idleThreadId', tickTimerThreadId' ~\}
\also
    allCondvars' = \{~ zThreadInstances(idleThreadId').builtinCondvarId, \\
\t3                    zThreadInstances(tickTimerThreadId').builtinCondvarId ~\}
\also
    allTimers' = \{~ zThreadInstances(idleThreadId').delayTimerId, \\
\t3                  zThreadInstances(tickTimerThreadId').delayTimerId ~\}
\also
    timerTicksSinceBoot' = 0
\also
    \theta~interruptNestingLevelStack' = \theta~InitInterruptNestingLevelStack
\also
    \theta~timerWheel' = \theta~InitTimerWheel
\also
    zCpuInterruptMaskingState' = cpuInterruptsEnabled
\also
    zCpuPrivilege' = cpuUnprivileged
\also
    zMemoryProtectionState' = memoryProtectionOn
\also
    runnableThreadQueues'(min~ ValidInterruptPriorityIdType) = \langle idleThreadId \rangle
\also
    runnableThreadQueues'(max~ ValidInterruptPriorityIdType) = \langle tickTimerThreadId \rangle
\also
     \forall p: ValidThreadPrioirtyType \setminus \\
\t2         \{ \min~ValidThreadPrioirtyType, \max~ValidThreadPrioirtyType \} @ \\
\t1      runnableThreadQueues'(p) = \emptyset
\end{schema}

\clearpage
\section{Starting the Per-CPU \emph{HiRTOS} Thread Scheduler}

When calling the \verb`HiRTOS.Start_Thread_Scheduler` \emph{HiRTOS} API, on a given
CPU core, RTOS multi-tasking is started on the given CPU, as described by the
precondition/postcondition contract shown below:

\begin{schema}{HiRtosStartThreadScheduler}
    \Delta HiRtosCpuInstanceType \\
\where
    threadSchedulerState = threadSchedulerStopped
\also
    currentThreadId = invalidThreadId
\also
    currentAtomicLevel = AtomicLevelNone
\also
   zCpuPrivilege = cpuPrivileged
\also
    currentCpuExecutionMode = cpuExecutingResetHandler
\also
\also
    threadSchedulerState' = threadSchedulerRunning
\also
    currentThreadId' = zGetHighestPriorityThread(cpuId)
\also
    currentAtomicLevel' = AtomicLevelNone
\also
   zCpuPrivilege = cpuUnprivileged
\also
    currentCpuExecutionMode' = cpuExecutingThread
\end{schema}

\section{Entering \emph{HiRTOS} from Interrupt Context}

After calling the \verb$HiRTOS.Enter_Interrupt_Context$ \emph{HiRTOS} API, from an ISR on a given CPU core, RTOS multi-tasking
the \emph{HiRTOS} environment for interrupt context is entered.

\begin{schema}{HiRtosEnterInterruptContext}
    \Delta HiRtosInstanceType \\
    zCpuId?: CpuIdType \\
    zInterruptId?: InterruptIdType \\
\where
\end{schema}

\section{Exiting \emph{HiRTOS} from Interrupt Context}

After calling the \verb$HiRTOS.Exit_Interrupt_Context$ \emph{HiRTOS} API, from an ISR on a given CPU core, RTOS multi-tasking
the \emph{HiRTOS} environment for interrupt context is exited.

\begin{schema}{HiRtosExitInterruptContext}
    \Delta HiRtosInstanceType \\
    zCpuId?: CpuIdType \\
    zInterruptId?: InterruptIdType \\
\where
\end{schema}

???
\clearpage
\subsection{CPU Controllers}

\begin{schema}{CpuController}
	ThreadScheduler \\
    cpuId: CpuIdType \\
    zExecutionContexts: \finset_1 ExecutionContext \\
    preemptedBy: ExecutionContext \pinj ExecutionContext \\
    timers: \finset Timer \\
  	zIterruptChannelToInterrupt: INTERRUPT\_CHANNEL \inj Interrupt \\
    interrupts: \finset_1 Interrupt \\
    tickTimerInterrupt: Interrupt \\
    runningExecutionContext: ExecutionContext \\
    nestedInterruptCount: 0 \upto kMaxNumInterruptChannelsPerCpu \\
	activeInterruptsBitMap: \finset INTERRUPT\_CHANNEL \\
    activeInterrupts: \finset Interrupt \\
\where
	 \ran zIterruptChannelToInterrupt = interrupts
\also
     zExecutionContexts = \\
\t1     \{ t: threads @ t.executionContext \} \cup \{ i: interrupts @ i.executionContext \}
\also
     \{ t: threads @ t.executionContext \} \cap \{ i: interrupts @ i.executionContext \} = \emptyset
\also
     \forall et: zExecutionContexts @ et.cpuId = cpuId
\also
	 activeInterrupts = \{ iv: activeInterruptsBitMap @ zIterruptChannelToInterrupt(iv) \}
\also
     nestedInterruptCount = \# activeInterrupts
\also
	 nestedInterruptCount = 0 \iff \\
\t1 	runningExecutionContext \in \{ t: zRunnableThreads @ t.executionContext \}
\also
     nestedInterruptCount > 0 \iff \\
\t1		runningExecutionContext \in \{ i: activeInterrupts @ i.executionContext \}
\end{schema}

Invariants:
\begin{itemize}
\item There can be more than one interrupt with the same interrupt priority. Interrupt
    scheduling is done by hardware, by the interrupt controller.
\item The same interrupt cannot be nested.
\end{itemize}

$ThreadScheduler$ represents the state variables of the Per-CPU thread scheduler.

\clearpage
\begin{schema}{ThreadScheduler}
 	zThreadIdToThread: THREAD\_ID \pinj Thread \\
    threads: \finset_1 Thread \\
    zUserThreads: \finset Thread \\
    zSystemThreads: \finset_1 Thread \\
    idleThread: Thread \\
    runningThread: Thread \\
    runnableThreadPrioritiesBitMap: \finset_1 THREAD\_PRIO \\
    runnableThreadQueues: THREAD\_PRIO \inj ThreadQueue \\
    zRunnableThreads: \finset_1 Thread \\
\where
     \ran zThreadIdToThread = threads
\also
	 zRunnableThreads = \\
\t1 \bigcup \{ i: THREAD\_PRIO @ \ran (runnableThreadQueues(i)).zElements \}
\also
     zRunnableThreads \neq \emptyset \land zRunnableThreads \subseteq threads
\also
     threads = zUserThreads \cup zSystemThreads
\also
     zUserThreads \cap zSystemThreads = \emptyset
\also
     \forall t: zSystemThreads @ t.executionContext.cpuPrivilege = cpuPrivileged
\also
     \forall t: zUserThreads @ \\
\t1      t.executionContext.contextType = threadContext
\also
     idleThread \in zSystemThreads
\also
	 zThreadIdToThread(0) = idleThread
\also
     runningThread \in zRunnableThreads \land runningThread.state = kRunning
\also
     \forall t: zRunnableThreads \setminus \{ runningThread \} @ t.state = kRunnable
\also
     \forall t: threads \setminus zRunnableThreads @ \\
\t1     t.state \notin \{kRunnable, kRunning \}
\also
	\ran (runnableThreadQueues(kLowestThreadPriority)).zElements = \{ idleThread \}
\also
  	\forall t: threads @ \\
\t1 	runningThread.currentPriority \geq t.currentPriority
\also
  	\forall prio: runnableThreadPrioritiesBitMap @ prio \in \dom runnableThreadQueues
\end{schema}

Invariants:
\begin{itemize}
\item The running thread is always the highest priority thread. There can be more than one
thread with the same thread priority. Threads of equal priority are time-sliced in a
round-robin fashion.
\item Each CPU has an idle thread. The idle thread has the lowest priority and cannot get
blocked on any mutex or condvar, but it is the only thread that can execute an instruction
that stops the processor until an interrupt happens.
\end{itemize}

\begin{schema}{ThreadQueue}
    GenericLinkedList[Thread] \\
\end{schema}

\clearpage
\subsection{ExecutionContext}

\begin{schema}{ExecutionContext}
    cpuRegisters: CpuRegisterIdType \inj CpuRegisterValueType \\
    stackPointer: MemoryAddressType \\
    cpuId: CpuIdType \\
    cpuPrivilege: CpuPrivilegeType \\
    contextType: ExecutionContextType \\
    exeStackTopEnd: MemoryAddressType \\
    exeStackBottomEnd: MemoryAddressType \\
 \where
    stackPointer \in cpuRegisters
\also
    kWordValue(stackPointer) \in \dom executionStack
\also
    exeStackTopEnd < exeStackBottomEnd
\also
    exeStackTopEnd \upto exeStackBottomEnd \subset kValidRamWordAddresses
\also
    \dom executionStack = exeStackTopEnd + 1 \upto exeStackBottomEnd
\also
	\dom executionStack \subset kValidRamWordAddresses
\also
	\dom executionStack \cap kReadOnlyAddresses = \emptyset
\end{schema}


\subsection{Threads}

\begin{schema}{Thread}
    executionContext: ExecutionContext \\
    threadID: THREAD\_ID \\
    threadFunction: kExecutableAddresses \\
    state: THREAD\_STATE \\
	basePriority: THREAD\_PRIO \\
	currentPriority: THREAD\_PRIO \\
    listNode: LIST\_NODE \\
    deadlineToRun: \nat \\
\where
	currentPriority \geq basePriority
\also
	executionContext.contextType = kThreadContext
\also
    \# executionContext.executionStack = kThreadStackSizeInWords
\end{schema}

User-created threads run in the CPU's unprivileged mode and system internal threads run in the CPU's privileged mode.
This is to prevent user threads to execute privileged instructions. If a
user thread needs to execute a provileged instruction, it needs to first switch the CPU to privileged mode.

Invariants:
\begin{itemize}
\item The current priority of a thread can never be lower than its base priority. The
current priority can be higher than the base priority when it acquires a mutex that has
higher priority than the thread's base priority.
\item A thread never gets blocked trying to acquire a mutex that has the same priority
as the thread. Still, the thread needs to acquire the mutex, since other threads with
the same prioirity may also try to acquire the same mutex, if the running thread gets
switched out due running out of its time slice.
\item A thread should never try to acquire a mutex of lower priority than the thread's priority. Indeed, It does not need to, as it cannot be preemted by lower priority threads.
\end{itemize}

\subsection{Interrupts}

\begin{schema}{Interrupt}
    executionContext: ExecutionContext \\
    interruptChannel: INTERRUPT\_CHANNEL \\
	isrFunction: kExecutableAddresses \\
\where
	executionContext.contextType = kInterruptContext
\also
	executionContext.cpuPrivilege = cpuPrivileged
\also
    \# executionContext.executionStack = kInterruptStackSizeInWords
\end{schema}

Interrupt execution contexts run in privileged mode. To ensure that a higher
priority interrupt is not delayed by a lower priority interrupt, nested
interrupts are supported. To this end, interrupt service routines (ISRs)
run with interrupts enabled by default. However, interrupts with the same or
lower priority cannot interrupt the CPU until we finish servicing the current
interrupt, as the interrupt controller is expected to only raise interrupts
with higher priority than the current one being serviced. (The last step in
servicing an interrupt is to notify the interrupt controller of the
completion of servicing the interrupt).

\subsection{Timers}

\begin{schema}{Timer}
    counter: \nat \\
%\where
\end{schema}

%\clearpage

\subsection{Mutexes}

\begin{schema}{Mutex}
	waitingThreads: ThreadQueue \\
    synchronizationScope: SynchronizationScopeType \\
    priority: MutexPriorityType \\
\end{schema}

\emph{HiRTOS} mutexes implement the priority ceiling protocol. That is, each mutex has a priority
associated with it, which is the priority of the highest priority task that accesses the
resource protected by the mutex, or the lowest interrupt priorirty, in case if an ISR
accesses the resource protected by the mutex.
The mutex is supposed be acquired by threads that have lower priority than the mutex's
priority. If the mutex has prioirty higher or equal to the lowest interrupt priority,
acquiring the mutex also disables interrupts in the CPU.

When a mutex is released and another thread is waiting to acquire it, the ownership of the mutex
is transferred to the first waiter, and this waiter is made runnable. This is so that if the
previous owner has higher priority and tries to acquire it again, it will get blocked. Otherwise,
the highest priority thread will keep running, acquiring and releasing the mutex without giving
a chance to the low-priority waiting thread to ever get it.

The queue of waiters on a mutex is strictly FIFO, not priority based. This is to ensure
fairness for lower priority threads. Otherwise, lower priority threads may starve waiting
to get the mutex, as higher priority threads keep acquiring it first.

\subsection{Condition Variables}

\begin{schema}{Condvar}
    waitingThreads: ThreadQueue \\
    synchronizationScope: SYNCHRONIZATION\_SCOPE \\
%\where
\end{schema}

Besides the traditional condvar ``wait'' primitive, there is a ``wait with interrupts disabled''
primitive, intended to be used to synchronize a waiting thread with an ISR that is supposed to signal
the corresponding condvar on which the thread is waiting. The waiting thread must have interrupts
disabled in the processor, when it calls the ``wait with interrupts disabled'' primitve.

If more than one thread is waiting on the condvar, the ``signal'' primitive will wake up the
first thread in the condvar's queue. The ``broadcast'' primitive wakes up all the waiting threads.

There is a variation of the ``wait'' primitive that includes a timeout.

\emph{HiRTOS} will not provide semaphore primitives as part of its APIs, as semaphores can be
easily implemented using condition variables and mutexes, for semaphores used only by threads.
For semaphores signaled from ISRs, they can be implemented with a combination of condition
variables and disabling interrupts, since mutexes cannot be used in ISRs. In this case, the thread
waiting on the condition variable to be signaled by an ISR, disables interrupts before checking
the condition and calls the ``wait for interrupt'' primitive, if the condition has not been met.
Otherwise, missed ``wake-ups'' could happen due to a race condition between the thread and the ISR.

%\subsection{Semaphores}

%\begin{schema}{Semaphore}
%    counter: \nat \\
%	counterNonZeroCondVar: Condvar \\
%\where
%    counterNonZeroCondVar.synchronizationScope = kLocalCpuInterruptAndThread
%\end{schema}

\subsection{Message Channels}

\begin{schema}{MessageChannel}
    GenericCircularBuffer[WORD\_LOCATION] \\
\end{schema}

\clearpage
\subsection{Generic Data Structures}

\subsubsection{Generic Linked Lists}

\begin{schema}{GenericLinkedList}[ElementType]
    listAnchor: LIST\_NODE \\
    numNodes: \nat \\
    zNodes: \finset LIST\_NODE \\
    zElements: \iseq ElementType \\
    zNodeToElem: LIST\_NODE \finj ElementType \\
    zNextNode: LIST\_NODE \finj LIST\_NODE \\
    zPrevNode: LIST\_NODE \finj LIST\_NODE \\
	zNodeToListAnchor: LIST\_NODE \finj LIST\_NODE \\
\where
    listAnchor \notin zNodes
\also
	numNodes = \# zNodes
\also
    \dom zNodeToElem = zNodes
\also
    \ran zNodeToElem = \ran zElements
\also
    \dom zNextNode = zNodes \cup \{listAnchor\}
\also
    \ran zNextNode = zNodes \cup \{listAnchor\}
\also
    \dom zPrevNode = \dom zNextNode
\also
    \ran zPrevNode = \ran zNextNode
\also
    \# zElements = \# zNodes
\also
    head~zElements = zNodeToElem(zNextNode(listAnchor)) \iff zElements \neq \emptyset
\also
    last~zElements = zNodeToElem(zPrevNode(listAnchor)) \iff zElements \neq \emptyset
\also
    head~zElements = last~zElements \iff \# zElements = 1
\also
    \forall x: zNodes @ \\
\t1      zPrevNode(zNextNode(x)) = x \land zNextNode(zPrevNode(x)) = x \land \\
%\t1      (zNodeToElem(x)).listNode = x \land \\ XXX
\t1      zNodeToListAnchor(x) = listAnchor
\also
    \forall x: zNodes @ \\
\t1      zNextNode^{\# zNodes + 1}(x) = x \land zPrevNode^{\# zNodes + 1}(x) = x
\also
    \forall x: zNodes; k: 1 \upto \# zNodes @ \\
\t1     zNextNode^{k}(x) \neq x \land zPrevNode^{k}(x) \neq x
\also
	 zNextNode(listAnchor) = zNodeToElem\inv(zElements(0))
\also
	 zPrevNode(listAnchor) = zNodeToElem\inv(last(zElements))
\also
     zNextNode(listAnchor) = listAnchor \iff zNodes = \emptyset
\also
    zPrevNode(listAnchor) = listAnchor \iff zNextNode(listAnchor) = listAnchor
\also
    zNextNode(listAnchor) = zPrevNode(listAnchor) \iff \# zNodes \leq 1
\end{schema}

\subsubsection{Generic Circular Buffers}

\begin{schema}{GenericCircularBuffer}[EntryType]
    zEntries: \iseq EntryType \\
    numEntries: \nat_1 \\
    entriesFilled: \nat \\
    readCursor: \nat \\
    writeCursor: \nat \\
    synchronizationScope: SYNCHRONIZATION\_SCOPE \\
    mutex: Mutex \\
    notEmptyCondvar: Condvar \\
    notFullCondvar: Condvar \\
\where
   \# zEntries = numEntries
\also
    entriesFilled \in 0 \upto numEntries
\also
   readCursor \in 0 \upto numEntries - 1
\also
   writeCursor \in 0 \upto numEntries - 1
\also
   writeCursor = readCursor \iff \\
\t1 (entriesFilled = 0 \lor entriesFilled = numEntries)
\also
    notEmptyCondvar \neq notFullCondvar
\also
    notEmptyCondvar.synchronizationScope = synchronizationScope
\also
    notFullCondvar.synchronizationScope = synchronizationScope
\end{schema}

If $synchronizationScope$ is $kLocalCpuInterruptAndThread$, the circular buffer operations
disable interrupts instead of using the circular buffer's mutex. If a circular buffer is empty,
a reader will block until the buffer is not empty.
Three behaviors are possible for writers when a circular buffer is full: block until there is
room to complete the write, drop the item to be written, overwrite the oldest entry with the
new item.

\clearpage
\begin{thebibliography}{9}

\bibitem{libcThreads}
ISO, ``N2731: Working draft of the C23 standard, section 7.26'', October 2021 \\
\url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2596.pdf#page=345&zoom=100,102,113}

\bibitem{prioCeiling}
Lui Sha et al, ``Priority Inheritance Protocols: An Approach to Real-Time Synchronization'', IEEE Transactions on Computers, September 1990 \\
\url{https://www.csie.ntu.edu.tw/~r95093/papers/Priority%20Inheritance%20Protocols%20An%20Approach%20to%20Real-Time%20Synchronization.pdf}

\bibitem{Zrm}
Mike Spivey, ``The Z Reference Manual'', second edition, Prentice-Hall, 1992 \\
\url{http://spivey.oriel.ox.ac.uk/~mike/zrm/zrm.pdf}

\bibitem{WayofZ}
Jonathan Jacky, ``The Way of Z'', Cambridge Press, 1997 \\
\url{http://staff.washington.edu/jon/z-book/index.html}

\bibitem{Fuzz}
Mike Spivey, ``The Fuzz checker'' \\
\url{http://spivey.oriel.ox.ac.uk/mike/fuzz}

\bibitem{DbC}
Bertrand Meyer, ``Touch of Class: Learning to Program Well with Objects and Contracts'', Springer, 2009 \\
\url{http://www.amazon.com/dp/3540921443}

\bibitem{SparkAda}
John W. McCormick, Peter C. Chapin,``Building High Integrity Applications with SPARK'', Cambridge University Press, 2015 \\
\url{https://www.amazon.com/Building-High-Integrity-Applications-SPARK/dp/1107040736}

\bibitem{gnatprove}
AdaCore,``Formal Verification with GNATprove'' \\
\url{https://docs.adacore.com/spark2014-docs/html/ug/en/gnatprove.html}

\end{thebibliography}

\end{document}
